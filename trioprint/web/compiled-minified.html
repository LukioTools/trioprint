<!DOCTYPE html><html lang="en"><head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <style>:root{ --bg-entry-dark: #151d2b; --bg-entry-light: #1f2333; --bg-entry-selected: #053846; --bg-entry-hover: #133548; --bg-bar: #182030; --fg-normal: #d1dae3; --fg-dir: #3dade8; --border-normal: #474f5d;}*{ min-width: 0;}*::-webkit-scrollbar { width: 5px; background: transparent; border-radius: 3px; height: 6px;}*::-webkit-scrollbar-thumb { background: transparent; }*:hover::-webkit-scrollbar-thumb { background: grey; }button{ background-color: white; border-radius: 2px;}@keyframes scrollbarFadeIn { 0% { opacity: 1; } 100% { opacity: 0; }}@keyframes scrollbarFadeOut { 0% { opacity: 0; } 100% { opacity: 1; }}p{ margin: 0px; margin-right: 10px;}html{ max-height: 100vh; max-width: 100vw; border-color: var(--border-normal); color: var(--fg-normal);}body{ margin: 0px; padding: 0px; width: 100vw; height: 100vh; max-height: 100vh; background-color: var(--bg-bar)}.unstyled-button{ all: unset; display: inline-block; padding: 10px 20px; margin: 5px; text-align: center; cursor: pointer; font-size: 16px;}.scroll-button{ all: unset; display: inline-block; text-align: center; cursor: pointer; font-size: 16px;}.directory-setting-seperator{ height: 40%; display: flex;}.bar{ background-color: var(--bg-bar);}.status-bar{ height: calc(60% - 1px); border-width: 0px 0px 1px 0px; border-style: solid; border-color: var(--border-normal); display: flex; flex-flow: row; overflow-y: scroll; overflow-x: clip;}.dir-view{ height: 100%; width: 60%; max-height: 100%;}.dirent{ width: 100%; height: 2em; display: flex; flex-flow: row; align-items: center;}.control-button-holder{ margin: 10px; display: flex; flex-direction: row; align-items: center; justify-content: center;}.control-button{ all: unset; display: inline-block; padding: 1px 5px; text-align: center; cursor: pointer; background-color: #133548; width: 50px; height: 50px; margin-left: 7px; margin-right: 7px; font-size: 15px; border-radius: 10px; outline: none; box-shadow: none; font-weight: bold;}.EMS{ background-color: rgb(252, 72, 72);}.slidecontainer{ margin-top: 10px;}.dir-files{ width: 100%; height: 80%; overflow: scroll; overflow-x: hidden; background-color: var(--bg-bar);}.dirent:nth-child(even){ background-color: var(--bg-entry-dark);}.dirent:nth-child(odd){ background-color: var(--bg-entry-light);}.dirent:hover{ background-color: var(--bg-entry-hover) !important;}.dir-selected-file{ background-color: var(--bg-entry-selected);}.dirent-item{ display: flex; flex-direction: row; align-items: center; height: 100%;}.dirent-item:hover{ cursor: pointer;}.dirent-item:first-child{ width: 100%; overflow-x: auto; overflow-y: hidden; white-space: nowrap; padding-left: 0em; transition: padding-left 2s; transition-timing-function: cubic-bezier(0,1.23,0,.92);}.dirent-item:first-child:hover{ padding-left: 1em; transition: padding-left 2s; transition-timing-function: cubic-bezier(0,1.23,0,.92);}.dirent-item:last-child{ margin-right: 1em;}.dirent-item:nth-child(n + 0){ margin-left: 1em;}.dirent-image{ min-width: 2em; height: 100%; transition: transform 0.3s; transition-timing-function: cubic-bezier(1,.82,0,1.3);}.dirent-image:hover{ transform: rotate(35deg); transition: transform 0.3s; transition-timing-function: cubic-bezier(1,.82,0,1.3);}.dirent-dir{ color: var(--fg-dir);}.dir-pwd{ border-radius: 0px; height: calc(2em - 1px); background-color: var(--bg-bar) !important; border-color: var(--border-normal); border-width: 0px 0px 1px 0px; border-style: solid; display: flex; align-items: center;}.dir-pwd-item{ display: flex; flex-direction: row; align-items: center; height: 100%; margin-left: 1em;}.new-dir-item{ display: flex; flex-direction: row; align-items: center; height: 100%; margin-left: 1em;}.new-dir-textfield { height: calc(1em + 6px); background-color: inherit; outline: none !important; color: var(--fg-normal); padding: 0px; padding-left: 0.5em; padding-right: 0.5em; border: none;}.new-dir-textfield:focus{ border: white solid; border-width: 0px 0px 1px 0px;}.file-sync-wrong{ color: red;}.settings-bar{ cursor: default; background-color: var(--bg-bar) !important; height: 100%; width: 100%; overflow-y: auto; overflow-x: hidden;}.status-item{ width: 100%; height: 100%; cursor: default; background-color: var(--bg-bar) !important; overflow-y: auto;}.resize-handle{ display: inline-block; cursor: ew-resize; padding-right: 8px; background-color: var(--bg-bar); border-color: var(--border-normal); border-width: 0px 1px 0px 0px; border-style: solid; width: 33.33vw; height: 100%;}.resize-handle:last-child{ cursor: default; background-color: var(--bg-bar); border-color: var(--border-normal); border-width: 0px 0px 0px 0px; border-style: none;}.resize-handle-setting{ cursor: ew-resize; padding-left: 8px; border-color: var(--border-normal); border-width: 0px 0px 0px 1px; border-style: solid; width: 20%;}.cmd_controls { position: absolute; top: 0; width: 100%; height: 20px; background: #151d2b; border-bottom: 1px solid #ccc; z-index: 10;}#scroll-container { width: 100%; height: 100%; overflow-y: auto; box-sizing: border-box;}#resume-button{ color: white;}#resume-button:hover{ color: rgb(0, 17, 255);}.setting-number{ display: flex; position: relative; font-size: 15px;}.setting-number div{ padding-left: 10px;}.setting-checkmark { display: block; position: relative; padding-left: 35px; margin-bottom: 12px; cursor: pointer; font-size: 15px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .setting-checkmark input { position: absolute; opacity: 0; cursor: pointer; height: 0; width: 0; } .checkmark { position: absolute; top: 0; left: 0; height: 25px; width: 25px; background-color: #eee; } .setting-checkmark:hover input ~ .checkmark { background-color: #ccc; } .setting-checkmark input:checked ~ .checkmark { background-color: #2196F3; } .checkmark:after { content: ""; position: absolute; display: none; } .setting-checkmark input:checked ~ .checkmark:after { display: block; } .setting-checkmark .checkmark:after { left: 9px; top: 5px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; -webkit-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); }</style> <style>.circular-progress-skill{ width: 160px; height: 160px; display: flex; justify-content: center; align-items: center; position: relative; }.circular-progress-svg{ position: absolute; top: 0; left: 0; transform: rotate(-90deg);}#circular-progress-number{ font-weight: 600; font-size: 30px;}.circular-progress-circle{ fill: none; stroke: rgb(255, 255, 255); stroke-width: 10px; stroke-dasharray: 450; stroke-dashoffset: 0; transition: stroke-dashoffset 1s ease; --circular-progress-circle-dash: 0;}.circular-progress-circle-progress{ stroke-dashoffset: var(--circular-progress-circle-dash);}.progress-type{ text-align: center;}</style> <title>Interface</title></head><body id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" onload="files(); getSettings();"> <script> function xhrFetch(url, options) { options = options || {}; return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); xhr.open(options.method || 'GET', url); if (options.headers) { for (var key in options.headers) { if (options.headers.hasOwnProperty(key)) { xhr.setRequestHeader(key, options.headers[key]); } } } if (options.responseType) { xhr.responseType = options.responseType; } if (xhr.upload && options.onProgress) { xhr.upload.onprogress = function (event) { if (event.lengthComputable) { const progress = (event.loaded / event.total) * 100; options.onProgress(progress, event.loaded, event.total); } }; } xhr.onload = function () { if (xhr.status >= 200 && xhr.status < 300) { resolve({ ok: true, status: xhr.status, statusText: xhr.statusText, json: function () { return Promise.resolve(JSON.parse(xhr.responseText)); }, text: function () { return Promise.resolve(xhr.responseText); } }); } else { reject(new Error('HTTP Error: ' + xhr.status)); } }; xhr.onerror = function () { reject(new Error('Network Error')); }; xhr.send(options.body || null); }); } </script> <script> function clipboard(el) { navigator.clipboard.writeText(el.innerText).then(function () { console.log('Async: Copying to clipboard was successful!'); }, function (err) { console.error('Async: Could not copy text: ', err); }); } function remove(filename) { path = cwd + filename; xhrFetch(`/fm/remove/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`File '${path}' removed successfuly :3`) else console.log(`Failed to remove file '${path}'`) files(); }) } function mkdir(dirname) { path = cwd + dirname; xhrFetch(`/fm/mkdir/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`) else console.log(`Failed to make directory '${path}'`) files(); }) } function printFile(dirname) { path = cwd + dirname; console.log("kek"); xhrFetch(`/device/print/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`) else console.log(`Failed to make directory '${path}'`) files(); }) } function chdir(name) { oldcwd = cwd; cde = document.getElementById("cwd"); cwd += name; files() .catch(function (err) { console.error("error changing directory to: ", cwd); console.log("reverting back to: ", oldcwd); cwd = oldcwd; cde.innerText = cwd; }); cde.innerText = cwd; } function chdir_back() { if (cwd == "/") return; oldcwd = cwd; cde = document.getElementById("cwd"); len = cwd.length - 2; cwd = cwd.substring(0, cwd.lastIndexOf('/', len)); if (cwd.length == 0) cwd = "/"; console.log("changing directory to", cwd); files() .catch(function (err) { console.error("error changing directory to: ", cwd); console.log("reverting back to: ", oldcwd); cwd = oldcwd; cde.innerText = cwd; }); cde.innerText = cwd; } function file_on_click(el) { if (el.getAttribute("isDirectory") == "true") chdir(el.innerText); else return clipboard(el); } cwd = "/"; const dirent_item = "dirent-item "; function create_file_element(filename) { dirent = document.createElement("div"); dirent.setAttribute("class", "dirent"); filesize = ""; isDirectory = (filename[filename.length - 1] == '/'); { el = document.createElement("div"); classes = dirent_item; if (isDirectory) classes += "dirent-dir "; if (!isDirectory) { filesize = filename.substring(filename.lastIndexOf("_") + 1); filename = filename.substring(0, filename.lastIndexOf("_")); } el.setAttribute("isDirectory", isDirectory); el.setAttribute("onclick", "file_on_click(this)"); el.setAttribute("class", classes); el.appendChild(document.createTextNode(filename)); dirent.appendChild(el); } { classes = dirent_item + "dirent-image "; if (!isDirectory) { { if (filesize != undefined && filesize != 0) { el = document.createElement("a"); el.setAttribute("class", classes); el.setAttribute("style", "margin-right: 2em; margin-left: 1em; white-space: nowrap;"); const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB']; const factor = 1024; const unitIndex = Math.floor(Math.log(filesize) / Math.log(factor)); const fileSize = filesize / Math.pow(factor, unitIndex); el.appendChild(document.createTextNode(`${fileSize.toFixed(2)} ${units[unitIndex]}`)); } else { el = document.createElement("a"); el.setAttribute("class", classes); el.setAttribute("style", "margin-right: 2em; margin-left: 1em; white-space: nowrap;"); el.appendChild(document.createTextNode(`0 bytes`)); } dirent.appendChild(el); } { el = document.createElement("a"); el.setAttribute("class", classes); el.setAttribute("href", `/fm/downloadFile/?filename=${filename}`); el.setAttribute('download', ''); el.appendChild(document.createTextNode("DW")); dirent.appendChild(el); } { el = document.createElement("div"); el.setAttribute("class", classes); el.appendChild(document.createTextNode("PR")); el.setAttribute("onclick", `printFile("${filename}")`); dirent.appendChild(el); } } { el = document.createElement("div"); el.setAttribute("class", classes); el.setAttribute("onclick", `remove("${filename}")`); el.appendChild(document.createTextNode("RM")); dirent.appendChild(el); } } return dirent; } const rotate_rps = 0.5; const rotate_ups = 20; function rotate_file_load_icon() { fsi_el = document.getElementById("file-sync-icon"); angle = 25; increment = (360 * rotate_rps) / rotate_ups; int = setInterval(function () { fsi_el.setAttribute("style", `transform: rotate(${angle}deg);`); angle += increment; }, 1000 / 20) return int; } interval_id = []; function stop_file_load_icon() { fsi_el = document.getElementById("file-sync-icon"); interval_id.forEach(function (item, index, arr) { window.clearInterval(item); arr.splice(index, 1); }) fsi_el.setAttribute("style", ''); } wrong_timeout_id = null; function set_wrong() { const wrong_class = "file-sync-wrong"; element = document.getElementById("file-sync-icon"); element.classList.add(wrong_class); if (wrong_timeout_id != null) { clearTimeout(wrong_timeout_id); wrong_timeout_id = null; } wrong_timeout_id = setTimeout(function () { wrong_timeout_id = null; element.classList.remove(wrong_class); }, 5000) } function refresh_files(js) { df = document.getElementById("Directory Files"); df.innerHTML = ""; js.forEach(function (element) { e = create_file_element(element); df.appendChild(e); }); stop_file_load_icon(); } function files() { return new Promise(function (resolve, reject) { interval_id.push(rotate_file_load_icon()); xhrFetch(`/fm/ls/?path=${cwd}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (r) { return r.json(); }) .then(function (js) { return refresh_files(js) }) .catch(function (err) { console.error(err); set_wrong(); stop_file_load_icon(); reject(err); }); }) } function upload_file(file) { console.log(`uploading file: '${file.name}' to path '${cwd}'`); const formData = new FormData(); formData.append("file", file); xhrFetch(`/fm/uploadFile/?path=${cwd}`, { method: "POST", body: formData, onProgress: function (progress, loaded, total) { console.log(`Progress: ${progress.toFixed(2)}% (${loaded}/${total} bytes)`); updateProgress(progress.toFixed(2), "UPLOAD STATUS"); } }).then(function (respz) { console.log(respz); files(); }).catch(function (err) { console.error(err) }); } function dropHandler(ev) { console.log("File(s) dropped", ev); ev.preventDefault(); if (ev.dataTransfer.items) { [...ev.dataTransfer.items].forEach(function (item, i) { if (item.kind === "file") { upload_file(item.getAsFile()); } }); } else { [...ev.dataTransfer.files].forEach(function (file, i) { upload_file(file); }); } } function dragOverHandler(ev) { console.log("File(s) in drop zone", ev); ev.preventDefault(); } dir_settings_percent = 80; dir_status_percent = 80; function refresh_dir_status() { dv = document.getElementById("dir-set-sep"); st = document.getElementById("Status Bar"); dv.setAttribute("style", `width: ${dir_status_percent}%;`); st.setAttribute("style", `width: ${100-dir_status_percent}%;`); } function refresh_dir_set() { dv = document.getElementById("Directory View"); sc = document.getElementById("Settings Column Resizer"); dv.setAttribute("style", `width: ${dir_settings_percent}%;`); sc.setAttribute("style", `width: ${100-dir_settings_percent}%;`); } function resize_dir_set(ev) { try { dss = document.getElementById("dir-set-sep"); pos_element = document.getElementById("Settings Column Resizer"); rect = pos_element.getBoundingClientRect(); clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX); if (!clientX || clientX < rect.left - 15 || clientX > rect.left + 15) { return; } ev.preventDefault(); } catch (err) { alert(err); } function update(ev1) { try { currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1 .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX); if (!currentX) return; dir_settings_percent = (100 * currentX) / dss.clientWidth; dir_settings_percent = Math.max(1, Math.min(dir_settings_percent, 99)); refresh_dir_set(); } catch (err) { alert(err); } } function updateFinal(ev1) { update(ev1); document.removeEventListener("mouseup", updateFinal); document.removeEventListener("mousemove", update); document.removeEventListener("touchend", updateFinal); document.removeEventListener("touchmove", update); } document.addEventListener("mouseup", updateFinal); document.addEventListener("mousemove", update); document.addEventListener("touchend", updateFinal); document.addEventListener("touchmove", update); } var bars = [] function index_of_element(e) { const arr = e.parentElement.children; for (index = 0; index < arr.length; index++) { if (arr[index] == e) return index; } return null; } function refresh_bars() { sb = document.getElementById("Status Bar"); total = 0; last = 0; for (index = 0; index < bars.length; index++) { const element = sb.children[index]; const bar = bars[index]; barsize = Math.round(bar); element.setAttribute("style", `width: ${barsize-total}px;`); total += barsize; if (index == bars.length - 1) { last = barsize; } } sb.children[sb.children.length - 1].setAttribute("style", `width: ${sb.clientWidth-last}px;`); } var bar_resize_ongoing = false; function resize_vertical_bars(ev, index) { clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX); if (!clientX || clientX < bars[index] - 15 || clientX > bars[index] + 15) { return; } ev.preventDefault(); bar_resize_ongoing = true; function resize_bar(cursor_x) { if (index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) { cursor_x = bars[index + 1] - 8; } if (index >= 1 && bars[index - 1] + 8 > cursor_x) { cursor_x = bars[index - 1] + 8; } sbw = document.getElementById("Status Bar").clientWidth - 8; if (cursor_x > sbw) { cursor_x = sbw; } if (cursor_x < 8) { cursor_x = 8; } if ((index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) || index >= 1 && bars[index - 1] + 8 > cursor_x) { return; } bars[index] = cursor_x; } function intermission_reszie(ev1) { currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1 .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX); resize_bar(currentX); refresh_bars(); resizeTempHandler(); } function final_resize(ev1) { currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1 .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX); resize_bar(currentX); refresh_bars(); resizeTempHandler(); document.removeEventListener("mouseup", final_resize); document.removeEventListener("mousemove", intermission_reszie); document.removeEventListener("touchend", final_resize); document.removeEventListener("touchmove", intermission_reszie); bar_resize_ongoing = false; }; document.addEventListener("mouseup", final_resize); document.addEventListener("mousemove", intermission_reszie); document.addEventListener("touchmove", intermission_reszie); document.addEventListener("touchend", final_resize); } function begin_mkdir() { cd = document.getElementById("Directory Files"); const tf_placeholder = "Leave Empty to cancel"; const tf_name = "new-dir-name"; div = document.createElement('div'); div.id = "new-dir-dirent"; div.classList.add("dirent"); text_field_label = document.createElement('label'); text_field_label.setAttribute("for", tf_name); text_field_label.classList.add("new-dir-item"); text_field_label.innerText = "Directory Name"; text_field = document.createElement('input'); text_field.classList.add("new-dir-item", "new-dir-textfield"); text_field.setAttribute("type", "text"); text_field.setAttribute("name", tf_name); text_field.setAttribute("id", tf_name); text_field.setAttribute("placeholder", tf_placeholder); div.appendChild(text_field_label); div.appendChild(text_field); cd.appendChild(div); text_field.addEventListener("focusout", function (ev) { dirname = text_field.value; text_field_label.remove(); text_field.remove(); div.remove(); mkdir(dirname); }) text_field.focus(); } function sendBooleanSetting(pos, state) { xhrFetch(`/config/setDynamicConfig/?type=0&config=${pos}&status=${state}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }).then(function (respz) {}).catch(function (err) { alert("can't save settings: " + err); console.error(err) }); } function sendCharSetting(type, state) { xhrFetch(`/config/setDynamicConfig/?type=${type}&status=${state}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }).then(function (respz) {}).catch(function (err) { alert("can't save settings: " + err); console.error(err) }); } </script> <div id="Status Bar" class="bar status-bar"> <div id="status-1" class="resize-handle" onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}"> <div class="status-item"> <div style="display: flex; width: 100%; height: 100%; align-items: center; justify-content: center; flex-direction: column;"> <h1 id="Progress type" class="progress-type" >print status</h1> <div class="circular-progress-skill"> <div id="circular-progress-number"> </div> <svg class="circular-progress-svg" xmlns="http: width="160px" height="160px"> <defs> <linearGradient id="GradientColor"> <stop offset="0%" stop-color="#DA22FF" /> <stop offset="100%" stop-color="#9733EE" /> </linearGradient> </defs> <circle id="circular-progress-circle" class="circular-progress-circle" cx="80" cy="80" r="70" stroke-linecap="round" /> </svg> </div> <div class="control-button-holder"> <button class="control-button" onclick="updateProgress(67)">STOP</button> <button class="control-button EMS" onclick="updateProgress(20)">EMS</button> </div> </div> </div> </div> <div id="status-2" class="resize-handle" onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}"> <div class="status-item" id=""> <div style="display: flex; flex-direction: column; align-items: stretch; width: 100%; height: 100%;"> <div id="chart-temps-parent-container" style="flex-grow: 1; width: 100%; height: 100%;"> <div id="chart-temps-container" style="position: relative; width: 100%;"> <canvas id="temperatures"></canvas> </div> </div> </div> </div> </div> <div id="status-3" class="resize-handle"> <div class="status-item" style="position: relative;"> <div class="cmd_controls"> <button id="resume-button" class="scroll-button">Scroll</button> </div> <div id="scroll-container"></div> </div> </div> </div> <div id="dir-set-sep" class="directory-setting-seperator"> <div id="Directory View" class="dir-view"> <div id="Current Directory" class="dir-pwd dirent"> <button id="back" class="dir-pwd-item dirent-image unstyled-button" onclick="chdir_back()">BK</button> <button id="mkdir" class="dir-pwd-item dirent-image unstyled-button" onclick="mkdir()">MD</button> <button id="file-sync-icon" class="dir-pwd-item dirent-image unstyled-button" onclick="files()">RF</button> <div id="cwd" class="dir-pwd-item">/</div> </div> <div id="Directory Files" class="dir-files"> </div> </div> <div id="Settings Column Resizer" class="resize-handle-setting" onmousedown="resize_dir_set(event)"> <div id="Settings Column" class="bar settings-bar"> <div>Settings. Hover for more information</div> <br> <div>esp configuration</div> <br> <label class="setting-checkmark"> <input type="checkbox" id="debugViaSerial" name="debugViaSerial" value="0" onchange="sendBooleanSetting(0, +this.checked)" /> <div title="esp sends debugging messages via serial. If you dont have pc connected to usb output of esp disable this."> debug via serial</div> <span class="checkmark"></span> </label> <label class="setting-checkmark"> <input type="checkbox" id="debugViaWeb" name="debugViaWeb" value="coding" onchange="sendBooleanSetting(1, +this.checked)" /> <div title="esp sends debugging log via socket to web client.">debug via web interface</div> <span class="checkmark"></span> </label> <label class="setting-checkmark"> <input type="checkbox" id="showSentCommands" name="showSentCommands" value="coding" onchange="sendBooleanSetting(2, +this.checked)" /> <div title="When enabled esp is going to log sent commands via serial and/or socket">show sent commands</div> <span class="checkmark"></span> </label> <label class="setting-checkmark"> <input type="checkbox" id="queueStatus" name="queueStatus" value="coding" onchange="sendBooleanSetting(3, + this.checked)" /> <div title="Shows how many commands in queue">show queue status</div> <span class="checkmark"></span> </label> <label class="setting-checkmark"> <input type="checkbox" id="showFailedComamnds" name="showFailedComamnds" value="coding" onchange="sendBooleanSetting(4, + this.checked)" /> <div title="">show failed commands</div> <span class="checkmark"></span> </label> <label class="setting-number"> <input type="number" , id="pullerFrequency" , name="pullerFrequency" , min="1" , max="100" onblur="sendCharSetting(1, this.value)"> <div title="">puller frequency</div> </label> </div> </div> </div> <script> function progressType(type){ const h = document.getElementById("Progress type"); h.textContent = type; } function updateProgress(progress, type) { progressType(type) progress = Math.min(Math.max(progress, 0), 100); const circle = document.getElementById("circular-progress-circle"); const progressNumber = document.getElementById("circular-progress-number"); const radius = circle.r.baseVal.value; const circumference = 2 * Math.PI * radius; const offset = circumference - (progress / 100) * circumference; circle.style.setProperty('--circular-progress-circle-dash', offset); circle.classList.add("circular-progress-circle-progress") progressNumber.textContent = `${progress}%`; circle.offsetHeight; } updateProgress(0, "NO PRINT RUNNING"); </script> <script> function updateCheckboxState(checkboxId, isChecked) { const checkbox = document.getElementById(checkboxId); const checkmark = checkbox.nextElementSibling.nextElementSibling; checkbox.checked = !!(+isChecked); } function getSettings() { xhrFetch('/config/getDynamicConfig/', { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (response) { return response.text(); }) .then(function (data) { reversed = data.split('').reverse().join(''); return reversed; }) .then(function (config) { updateCheckboxState("debugViaSerial", config[0]); updateCheckboxState("debugViaWeb", config[1]); updateCheckboxState("showSentCommands", config[2]); updateCheckboxState("queueStatus", config[3]); updateCheckboxState("showFailedComamnds", config[4]); }) } </script> <script> </script> <script> var scrollContainer = document.getElementById('scroll-container'); var resumeButton = document.getElementById('resume-button'); var isAutoScrolling = true; var userInteracted = false; scrollContainer.addEventListener('scroll', function () { if (!userInteracted && scrollContainer.scrollTop + scrollContainer.clientHeight < scrollContainer .scrollHeight) { isAutoScrolling = false; userInteracted = true; } }); resumeButton.addEventListener('click', function () { isAutoScrolling = true; userInteracted = false; scrollContainer.scrollTop = scrollContainer.scrollHeight; }); </script> <script src="https: <script> const parentContainer = document.getElementById('chart-temps-parent-container'); const chartContainer = document.getElementById('chart-temps-container'); const canvas = document.getElementById('temperatures'); aspectRatio = 130 / 260; function resizeTempsCanvas() { const parentWidth = parentContainer.offsetWidth; const parentHeight = parentContainer.offsetHeight; const aspectRatio = 3 / 2; canvasWidth = parentWidth; canvasHeight = parentWidth / aspectRatio; if (canvasHeight > parentHeight) { console.log("height limit") canvasHeight = parentHeight; canvasWidth = parentHeight * aspectRatio; } console.log(canvasWidth + " : " + canvasHeight) canvas.width = canvasWidth; canvas.height = canvasHeight; chartContainer.style.width = `${canvasWidth}px`; chartContainer.style.height = `${canvasHeight}px`; } const xValues = []; const nozzempData = []; const nozzempTargerData = []; const bedTempData = []; const bedTempTargetData = []; const fanSpeedData = []; const printerTempChart = new Chart("temperatures", { type: "line", data: { labels: xValues, datasets: [{ data: nozzempData, borderColor: "#BD2D03", fill: false }, { data: nozzempTargerData, borderColor: "#F68462", fill: false }, { data: bedTempData, borderColor: "#107C99", fill: false }, { data: bedTempTargetData, borderColor: "#22C3EF", fill: false }, { data: fanSpeedData, borderColor: "#DDA512", fill: false }, ] }, options: { responsive: false, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, legend: { display: false } } }); function resizeTempHandler() { resizeTempsCanvas(); printerTempChart.resize(); printerTempChart.update(); }; resizeTempHandler(); </script> <script> function parseSerial(data) { if (typeof data !== 'string') return; if (data.includes("T:") || data.includes("B:") || data.includes("FAN0@")) { const regex = /T:([\d.]+)\s+\/([\d.]+).*B:([\d.]+)\s+\/([\d.]+).*FAN0@:(\d+)/; const match = data.match(regex); if (match) { const currentT = parseFloat(match[1]); const targetT = parseFloat(match[2]); const currentB = parseFloat(match[3]); const targetB = parseFloat(match[4]); const fanSpeed = parseInt(match[5], 10); const currentTime = xValues.length > 0 ? xValues[xValues.length - 1] + 1 : 0; xValues.push(currentTime); nozzempData.push(currentT); nozzempTargerData.push(targetT); bedTempData.push(currentB); bedTempTargetData.push(targetB); fanSpeedData.push(fanSpeed); if (xValues.length > 30) { xValues.shift(); nozzempData.shift(); nozzempTargerData.shift() bedTempData.shift() bedTempTargetData.shift() fanSpeedData.shift(); } printerTempChart.update(); } else { return null; } } else if (data.includes("commands completed:")) { const regex = /(\d+)\/(\d+)/; const match = data.match(regex); if (match) { const completed = parseInt(match[1], 10); const total = parseInt(match[2], 10); console.log("completed: " + completed / total + "%") updateProgress(Math.round((completed / total) * 100), "PRINT STATUS"); } } else if (data.includes("Clearing root cache...")) { window.location.reload(); } } Console_array = []; Console_max_size = 20; var connection = new WebSocket('ws: connection.onopen = function () { console.log('Connected to WebSocket'); }; connection.onerror = function (error) { console.log('WebSocket Error ', error); }; connection.onmessage = function (e) { parseSerial(e.data); elem = document.createElement('div'); elem.innerText = e.data; Console_array.push(elem); document.getElementById('scroll-container').appendChild(elem); if (isAutoScrolling) { scrollContainer.scrollTop = scrollContainer.scrollHeight; } if (Console_array.length > Console_max_size) Console_array.pop(); }; connection.onclose = function () { console.log('WebSocket connection closed'); }; </script> <script> document.getElementById("status-1").addEventListener("mousedown", function (ev) { resize_vertical_bars(ev, 0); }); document.getElementById("status-1").addEventListener("touchstart", function (ev) { resize_vertical_bars(ev, 0); }); document.getElementById("status-2").addEventListener("mousedown", function (ev) { resize_vertical_bars(ev, 1); }); document.getElementById("status-2").addEventListener("touchstart", function (ev) { resize_vertical_bars(ev, 1); }); document.getElementById("Settings Column Resizer").addEventListener("mousedown", function (ev) { resize_dir_set(ev); }); document.getElementById("Settings Column Resizer").addEventListener("touchstart", function (ev) { resize_dir_set(ev); }); window.addEventListener("DOMContentLoaded", function () { sb = document.getElementById("Status Bar"); width = sb.clientWidth; inc = width / sb.children.length; for (index = 0; index < sb.children.length; index++) { const element = sb.children[index]; element.setAttribute("style", `width: ${inc}px;`); if (index != 0) { bars.push(inc * index); } } refresh_dir_set(); files(); }) </script></body></html>