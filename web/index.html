<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="index.css">
    <title>Interface</title>

</head>

<body id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" onload="files(); getSettings();">


    <script>
        function xhrFetch(url, options) {
            options = options || {};
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();

                // Set up the method and URL
                xhr.open(options.method || 'GET', url);

                // Set request headers
                if (options.headers) {
                    for (var key in options.headers) {
                        if (options.headers.hasOwnProperty(key)) {
                            xhr.setRequestHeader(key, options.headers[key]);
                        }
                    }
                }

                // Set response type if defined in options
                if (options.responseType) {
                    xhr.responseType = options.responseType;
                }

                // Handle the response
                xhr.onload = function () {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve({
                            ok: true,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: function () {
                                return Promise.resolve(JSON.parse(xhr.responseText));
                            },
                            text: function () {
                                return Promise.resolve(xhr.responseText);
                            }
                        });
                    } else {
                        reject(new Error('HTTP Error: ' + xhr.status));
                    }
                };

                // Handle errors
                xhr.onerror = function () {
                    reject(new Error('Network Error'));
                };

                // Send the request with the provided body (if any)
                xhr.send(options.body || null);
            });
        }
    </script>

    <!--file view & navigation-->
    <script>
        function clipboard(el) {
            navigator.clipboard.writeText(el.innerText).then(function () {
                console.log('Async: Copying to clipboard was successful!');
            }, function (err) {
                console.error('Async: Could not copy text: ', err);
            });
        }

        function remove(filename) {
            path = cwd + filename;
            xhrFetch(`/fm/remove/?path=${path}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`File '${path}' removed successfuly :3`)
                    else console.log(`Failed to remove file '${path}'`)
                    files();
                })
        }

        function mkdir(dirname) {
            path = cwd + dirname;
            xhrFetch(`/fm/mkdir/?path=${path}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`)
                    else console.log(`Failed to make directory '${path}'`)
                    files();
                })
        }

        function printFile(dirname) {
            path = cwd + dirname;
            console.log("kek");
            xhrFetch(`/device/print/?path=${path}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`)
                    else console.log(`Failed to make directory '${path}'`)
                    files();
                })
        }

        function chdir(name) {
            oldcwd = cwd;
            cde = document.getElementById("cwd");
            cwd += name;
            files()
                .catch(function (err) {
                    console.error("error changing directory to: ", cwd);
                    console.log("reverting back to: ", oldcwd);
                    cwd = oldcwd;
                    cde.innerText = cwd;
                });
            cde.innerText = cwd;
        }

        function chdir_back() {
            if (cwd == "/") return;
            oldcwd = cwd;
            cde = document.getElementById("cwd");
            len = cwd.length - 2;
            cwd = cwd.substring(0, cwd.lastIndexOf('/', len));
            if (cwd.length == 0) cwd = "/";
            console.log("changing directory to", cwd);
            files()
                .catch(function (err) {
                    console.error("error changing directory to: ", cwd);
                    console.log("reverting back to: ", oldcwd);
                    cwd = oldcwd;
                    cde.innerText = cwd;
                });
            cde.innerText = cwd;
        }

        function file_on_click(el) {
            if (el.getAttribute("isDirectory") == "true") chdir(el.innerText);
            else return clipboard(el);
        }

        cwd = "/";
        const dirent_item = "dirent-item ";
        //when the icons are ready, insert them here
        /**
         * @param filename {string}
         * */
        function create_file_element(filename) {

            dirent = document.createElement("div");
            dirent.setAttribute("class", "dirent");
            filesize = "";
            isDirectory = (filename[filename.length - 1] == '/'); { // file
                el = document.createElement("div");
                classes = dirent_item;

                if (isDirectory) classes += "dirent-dir ";
                if (!isDirectory) {
                    filesize = filename.substring(filename.lastIndexOf("_") + 1);
                    filename = filename.substring(0, filename.lastIndexOf("_"));
                }

                el.setAttribute("isDirectory", isDirectory);
                el.setAttribute("onclick", "file_on_click(this)");
                el.setAttribute("class", classes);

                el.appendChild(document.createTextNode(filename));
                dirent.appendChild(el);
            } { //buttons
                classes = dirent_item + "dirent-image ";
                if (!isDirectory) { //download
                    el = document.createElement("a");
                    el.setAttribute("class", classes);
                    //el.setAttribute("onclick", `download("${filename}")`);
                    el.setAttribute("href", `/fm/downloadFile/?filename=${filename}`);
                    el.setAttribute('download', '');
                    el.appendChild(document.createTextNode("DW"));
                    dirent.appendChild(el);
                } { //print
                    el = document.createElement("div");
                    el.setAttribute("class", classes);
                    el.appendChild(document.createTextNode("PR"));
                    el.setAttribute("onclick", `printFile("${filename}")`);
                    dirent.appendChild(el);
                } { //remove
                    el = document.createElement("div");
                    el.setAttribute("class", classes);
                    el.setAttribute("onclick", `remove("${filename}")`);
                    el.appendChild(document.createTextNode("RM"));
                    dirent.appendChild(el);
                }
            }
            return dirent;
        }

        const rotate_rps = 0.5;
        const rotate_ups = 20;

        function rotate_file_load_icon() {
            fsi_el = document.getElementById("file-sync-icon");
            angle = 25;
            increment = (360 * rotate_rps) / rotate_ups;
            return setInterval(function () {
                fsi_el.setAttribute("style", `transform: rotate(${angle}deg);`);
                angle += increment;
            }, 1000 / 20)
        }

        interval_id = 0;

        function stop_file_load_icon(interval_id) {
            fsi_el = document.getElementById("file-sync-icon");
            fsi_el.setAttribute("style", '');
            clearInterval(interval_id);
        }

        wrong_timeout_id = null;

        function set_wrong() {
            const wrong_class = "file-sync-wrong";
            element = document.getElementById("file-sync-icon");
            element.classList.add(wrong_class);
            if (wrong_timeout_id != null) {
                clearTimeout(wrong_timeout_id);
                wrong_timeout_id = null;
            }
            wrong_timeout_id = setTimeout(function () {
                wrong_timeout_id = null;
                element.classList.remove(wrong_class);
            }, 5000)
        }

        function refresh_files(js) {
            df = document.getElementById("Directory Files");

            df.innerHTML = "";

            //df.replaceChildren();
            js.forEach(function (element) {
                console.log(element);
                e = create_file_element(element);
                df.appendChild(e);
            });

            stop_file_load_icon(interval_id);
        }

        function files() {
            document.getElementById('fetch').textContent = "listing";

            return new Promise(function (resolve, reject) {
                interval_id = rotate_file_load_icon();
                xhrFetch(`/fm/ls/?path=${cwd}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/text'
                        }
                    })
                    .then(function (r) {
                        return r.json();
                    })
                    .then(function (js) {
                        return refresh_files(js)
                    })
                    .catch(function (err) {
                        document.getElementById('fetch').textContent = "error: " + err;

                        console.error(err);
                        set_wrong();
                        stop_file_load_icon(interval_id);

                        reject(err);
                    });
            })
        }

        /**
         * @param file {Object}.
         * @param file.lastModified {number}.
         * @param file.name {string} The name of the file.
         * @param file.size {number} The size of the file.
         * @param file.type {string} The mimetype of the file.
         * @param file.webkitRelativePath {string | ""} The rel-path of the file.
         */
        function upload_file(file) {
            console.log(`uploading file: '${file.name}' to path '${cwd}'`);
            const formData = new FormData();
            formData.append("file", file);
            xhrFetch(`/fm/uploadFile/?path=${cwd}`, {
                method: "POST",
                body: formData
            }).then(function (respz) {
                console.log(respz);
                files();
            }).catch(function (err) {
                console.error(err)
            });
        }

        function dropHandler(ev) {
            console.log("File(s) dropped", ev);
            ev.preventDefault();
            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach(function (item, i) {
                    // If dropped items aren't files, reject them
                    if (item.kind === "file") {
                        upload_file(item.getAsFile());
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach(function (file, i) {
                    upload_file(file);
                });
            }
        }

        function dragOverHandler(ev) {
            console.log("File(s) in drop zone", ev);
            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();
            //document.getElementById("drop-zone").setAttribute("")
        }

        dir_settings_percent = 80;
        dir_status_percent = 80;

        function refresh_dir_status() {
            dv = document.getElementById("dir-set-sep");
            st = document.getElementById("Status Bar");
            dv.setAttribute("style", `width: ${dir_status_percent}%;`);
            st.setAttribute("style", `width: ${100-dir_status_percent}%;`);
        }

        function resize_dir_stat(ev) {
            function update(ev1) {
                dir_status_percent = 100 * ev1.clientY / document.body.clientHeight;
                if (dir_status_percent < 1) {
                    dir_status_percent = 1;
                } else if (dir_status_percent > 99) {
                    dir_status_percent = 99;
                }
                refresh_dir_status();
            }

            function updateFinal(ev1) {
                update(ev1);
                document.removeEventListener("mouseup", updateFinal);
                document.removeEventListener("mousemove", update);
            }
            document.addEventListener("mouseup", updateFinal);
            document.addEventListener("mousemove", update);
        }

        function refresh_dir_set() {
            dv = document.getElementById("Directory View");
            sc = document.getElementById("Settings Column Resizer");
            dv.setAttribute("style", `width: ${dir_settings_percent}%;`);
            sc.setAttribute("style", `width: ${100-dir_settings_percent}%;`);
        }


        function resize_dir_set(ev) {
            dss = document.getElementById("dir-set-sep");
            pos_element = document.getElementById("Settings Column Resizer");
            rect = pos_element.getBoundingClientRect();

            clientX = ev.clientX || (ev.touches && ev.touches[0].clientX);

            if (!clientX || clientX < rect.left - 5 || clientX > rect.left + 5) {
                console.log("Cursor/touch not near the resizable line");
                return; // Exit if cursor or touch is not near the resizable line
            }

            function update(ev1) {
                currentX = ev1.clientX || (ev1.touches && ev1.touches[0].clientX);
                if (!currentX) return;

                dir_settings_percent = (100 * currentX) / dss.clientWidth;
                dir_settings_percent = Math.max(1, Math.min(dir_settings_percent, 99)); // Clamp between 1% and 99%
                refresh_dir_set();
            }

            function updateFinal(ev1) {
                update(ev1);
                document.removeEventListener("mouseup", updateFinal);
                document.removeEventListener("mousemove", update);
            }

            document.addEventListener("mouseup", updateFinal);
            document.addEventListener("mousemove", update);
            document.addEventListener("touchend", updateFinal);
            document.addEventListener("touchmove", update);
        }

        // Attach both mousedown and touchstart
        document.getElementById("Settings Column Resizer").addEventListener("mousedown", resize_dir_set);
        document.getElementById("Settings Column Resizer").addEventListener("touchstart", resize_dir_set);

        var bars = []
        window.addEventListener("load", function () {
            console.log("loaded");
            sb = document.getElementById("Status Bar");
            width = sb.clientWidth;
            inc = width / sb.children.length;
            console.log(width, inc, sb);
            for (index = 0; index < sb.children.length; index++) {
                const element = sb.children[index];
                element.setAttribute("style", `width: ${inc}px;`);
                if (index != 0) {
                    bars.push(inc * index);
                }
            }
            refresh_dir_set();
            files();
        })

        function index_of_element(e) {
            const arr = e.parentElement.children;
            for (index = 0; index < arr.length; index++) {
                if (arr[index] == e) return index;
            }
            return null;
        }

        function refresh_bars() {
            sb = document.getElementById("Status Bar");
            total = 0;
            last = 0;
            for (index = 0; index < bars.length; index++) {
                const element = sb.children[index];
                const bar = bars[index];
                console.log("bar:", bar);
                console.log("bar-style", `width: ${bar}px;`);
                element.setAttribute("style", `width: ${bar-total}px;`);
                total += bar;
                if (index == bars.length - 1) {
                    last = bar;
                }
            }
            sb.children[sb.children.length - 1].setAttribute("style", `width: ${sb.clientWidth-last}px;`);
        }

        var bar_resize_ongoing = false;

        function resize_vertical_bars(ev, index) {
            console.log(ev);
            if (ev.clientX > bars[index] + 32 || ev.clientX < bars[index] - 32) return;

            bar_resize_ongoing = true;
            ev.preventDefault();

            function resize_bar(cursor_x) {
                if (index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) {
                    cursor_x = bars[index + 1] - 8;
                }
                if (index >= 1 && bars[index - 1] + 8 > cursor_x) {
                    cursor_x = bars[index - 1] + 8;
                }
                sbw = document.getElementById("Status Bar").clientWidth - 8;
                if (cursor_x > sbw) {
                    cursor_x = sbw;
                }
                if (cursor_x < 8) {
                    cursor_x = 8;
                }
                //idk anymore
                if ((index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) || index >= 1 && bars[index - 1] + 8 >
                    cursor_x) {
                    return;
                }
                bars[index] = cursor_x;
            }

            function intermission_reszie(ev1) {
                resize_bar(ev1.clientX);
                refresh_bars();
            }

            function final_resize(ev1) {
                resize_bar(ev1.clientX);
                refresh_bars();
                document.removeEventListener("mouseup", final_resize);
                document.removeEventListener("mousemove", intermission_reszie);
                bar_resize_ongoing = false;
            };
            document.addEventListener("mouseup", final_resize);
            document.addEventListener("mousemove", intermission_reszie);
        }

        function begin_mkdir() {
            cd = document.getElementById("Directory Files");

            /*
            div id="new-dir-dirent" class="dirent">
                <label for="new-dir-name" class="new-dir-item">Directory Name</label>
                <input class="new-dir-item new-dir-textfield" type="text" name="new-dir-name" id="new-dir-name" placeholder="Leave Empty to cancel">
            </div>
            */
            const tf_placeholder = "Leave Empty to cancel";
            const tf_name = "new-dir-name";

            div = document.createElement('div');
            div.id = "new-dir-dirent";
            div.classList.add("dirent");
            text_field_label = document.createElement('label');
            text_field_label.setAttribute("for", tf_name);
            text_field_label.classList.add("new-dir-item");
            text_field_label.innerText = "Directory Name";
            text_field = document.createElement('input');
            text_field.classList.add("new-dir-item", "new-dir-textfield");
            text_field.setAttribute("type", "text");
            text_field.setAttribute("name", tf_name);
            text_field.setAttribute("id", tf_name);
            text_field.setAttribute("placeholder", tf_placeholder);

            div.appendChild(text_field_label);
            div.appendChild(text_field);

            cd.appendChild(div);

            text_field.addEventListener("focusout", function (ev) {
                dirname = text_field.value;
                text_field_label.remove();
                text_field.remove();
                div.remove();

                mkdir(dirname);
            })
            text_field.focus();
        }

        function sendBooleanSetting(pos, state) {
            xhrFetch(`/config/setDynamicConfig/?config=${pos}&status=${state}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            }).then(function (respz) {
                console.log(respz);
                files();
            }).catch(function (err) {
                console.error(err)
            });
        }
    </script>


    <!-- Progress etc. on the top as a bar -->
    <div id="Status Bar" class="bar status-bar">
        <div id="1" class="resize-handle"
            onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}">
            <!--
                Use this shit for uplad thginf
                <form method='POST' action='/fm/uploadFile/' enctype='multipart/form-data'><input type='file' name='up-file'><input type='submit' value='Upload'></form>-->
            <div class="status-item">
                <div>
                    <p id="fetch">Check Fetch Support</p>
                </div>
            </div>
        </div>
        <div id="1" class="resize-handle"
            onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}">
            <div class="status-item">
                <br>
                <canvas id="temperatures" style="width:100%;max-width:600px"></canvas>
            </div>

        </div>
        <div id="3" class="resize-handle">
            <div class="status-item" style="position: relative;">
                <div class="cmd_controls">
                    <div id="resume-button">Scroll</div>
                </div>
                <div id="scroll-container"></div>
            </div>
        </div>
    </div>

    <div id="dir-set-sep" class="directory-setting-seperator">
        <div id="Directory View" class="dir-view">
            <div id="Current Directory" class="dir-pwd dirent">
                <button id="back" class="dir-pwd-item dirent-image unstyled-button" onclick="chdir_back()">BK</button>
                <button id="mkdir" class="dir-pwd-item dirent-image unstyled-button" onclick="mkdir()">MD</button>

                <button id="file-sync-icon" class="dir-pwd-item dirent-image unstyled-button"
                    onclick="files()">RF</button>


                <div id="cwd" class="dir-pwd-item">/</div>
            </div>
            <div id="Directory Files" class="dir-files">
                <!--
                    <div class="dirent">
                        <div class="dirent-item dirent-dir" isDirectory="true" onclick="file_on_click(this)">directory/</div>
                        <div class="dirent-item dirent-image">DW</div>
                        <div class="dirent-item dirent-image">PR</div>
                        <div class="dirent-item dirent-image">RM</div>
                    </div>
                    <div class="dirent">
                        <div class="dirent-item" onclick="file_on_click(this)">filename</div>
                        <div class="dirent-item dirent-image">DW</div>
                        <div class="dirent-item dirent-image">PR</div>
                        <div class="dirent-item dirent-image">RM</div>
                    </div>
                    <div id="new-dir-dirent" class="dirent">
                        <label for="new-dir-name" class="new-dir-item">Directory Name</label>
                        <input class="new-dir-item new-dir-textfield" type="text" name="new-dir-name" id="new-dir-name" placeholder="Leave Empty to cancel">
                        </div>
                        -->


            </div>
        </div>
        <div id="Settings Column Resizer" class="resize-handle-setting" onmousedown="resize_dir_set(event)">
            <div id="Settings Column" class="bar settings-bar">
                <div>Settings. Hover for more information</div>
                <br>
                <div>esp configuration</div>
                <br>
                <label class="setting">
                    <input type="checkbox" id="debugViaSerial" name="debugViaSerial" value="0"
                        onchange="sendBooleanSetting(0, +this.checked)" />
                    <div
                        title="esp sends debugging messages via serial. If you dont have pc connected to usb output of esp disable this.">
                        debug via serial</div>
                    <span class="checkmark"></span>
                </label>

                <label class="setting">
                    <input type="checkbox" id="debugViaWeb" name="debugViaWeb" value="coding"
                        onchange="sendBooleanSetting(1, +this.checked)" />
                    <div title="esp sends debugging log via socket to web client.">debug via web interface</div>
                    <span class="checkmark"></span>
                </label>

                <label class="setting">
                    <input type="checkbox" id="showSentCommands" name="showSentCommands" value="coding"
                        onchange="sendBooleanSetting(2, +this.checked)" />
                    <div title="When enabled esp is going to log sent commands via serial and/or socket">show sent
                        commands</div>
                    <span class="checkmark"></span>
                </label>

                <label class="setting">
                    <input type="checkbox" id="queueStatus" name="queueStatus" value="coding"
                        onchange="sendBooleanSetting(3, + this.checked)" />
                    <div title="Shows how many commands in queue">show queue status</div>
                    <span class="checkmark"></span>
                </label>


                <label class="setting">
                    <input type="checkbox" id="showFailedComamnds" name="showFailedComamnds" value="coding"
                        onchange="sendBooleanSetting(4, + this.checked)" />
                    <div title="">show failed commands</div>
                    <span class="checkmark"></span>
                </label>

            </div>
        </div>
    </div>

    <!-- Settings -->
     
    <script>

        function updateCheckboxState(checkboxId, isChecked) {
            const checkbox = document.getElementById(checkboxId);
            const checkmark = checkbox.nextElementSibling.nextElementSibling;

            // Set the checkbox's checked property
            checkbox.checked = !!(+isChecked);
            console.log(isChecked);
        }

        function getSettings() {
            xhrFetch('/config/getDynamicConfig/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                .then(function (response) {
                    return response.text();
                })
                .then(function (data) {
                    reversed = data.split('').reverse().join('');
                    return reversed;
                })
                .then(function (config) {
                    console.log("config: " + config[0]);
                    updateCheckboxState("debugViaSerial", config[0]);
                    updateCheckboxState("debugViaWeb", config[1]);
                    updateCheckboxState("showSentCommands", config[2]);
                    updateCheckboxState("queueStatus", config[3]);
                    updateCheckboxState("showFailedComamnds", config[4]);
                })
        }
    </script>

    <!--Serial scrolling-->
    <script>
        var scrollContainer = document.getElementById('scroll-container');
        var resumeButton = document.getElementById('resume-button');

        var isAutoScrolling = true;
        var userInteracted = false;

        // Stop scrolling when user interacts
        scrollContainer.addEventListener('scroll', function () {
            if (!userInteracted && scrollContainer.scrollTop + scrollContainer.clientHeight < scrollContainer
                .scrollHeight) {
                isAutoScrolling = false;
                userInteracted = true;
            }
        });

        // Resume scrolling on button press
        resumeButton.addEventListener('click', function () {
            console.log("should scroll");
            isAutoScrolling = true;
            userInteracted = false;
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>

    <script>
        const xValues = [];
        const nozzempData = [];
        const nozzempTargerData = [];
        const bedTempData = [];
        const bedTempTargetData = [];
        const fanSpeedData = [];

        const printerTempChart = new Chart("temperatures", {
            type: "line",
            data: {
                labels: xValues,
                datasets: [{
                        data: nozzempData,
                        borderColor: "#BD2D03",
                        fill: false
                    },
                    {
                        data: nozzempTargerData,
                        borderColor: "#F68462",
                        fill: false
                    },
                    {
                        data: bedTempData,
                        borderColor: "#107C99",
                        fill: false
                    },
                    {
                        data: bedTempTargetData,
                        borderColor: "#22C3EF",
                        fill: false
                    },
                    {
                        data: fanSpeedData,
                        borderColor: "#DDA512",
                        fill: false
                    },
                ]
            },
            options: {
                legend: {
                    display: false
                }
            }
        });
    </script>

    <!--serial console-->
    <script>
        function parseSerial(data) {
            // Ensure the input is a string and contains key markers we expect
            if (typeof data !== 'string' || !data.includes("T:") || !data.includes("B:") || !data.includes("FAN0@")) {
                console.log(typeof data);
                console.log(data.includes("T:"));
                console.log(data.includes("FAN0@"));
                console.error("Invalid input data");
                return;
            }

            // Regular expressions to extract T, B temperatures, and FAN0@ values
            const regex = /T:([\d.]+)\s+\/([\d.]+).*B:([\d.]+)\s+\/([\d.]+).*FAN0@:(\d+)/;

            // Execute the regex on the input string
            const match = data.match(regex);

            if (match) {
                const currentT = parseFloat(match[1]); // Current T temperature
                const targetT = parseFloat(match[2]); // Target T temperature
                const currentB = parseFloat(match[3]); // Current B temperature
                const targetB = parseFloat(match[4]); // Target B temperature
                const fanSpeed = parseInt(match[5], 10); // FAN0 speed

                const currentTime = xValues.length > 0 ? xValues[xValues.length - 1] + 1 : 0;

                xValues.push(currentTime);
                nozzempData.push(currentT);
                nozzempTargerData.push(targetT);
                bedTempData.push(currentB);
                bedTempTargetData.push(targetB);
                fanSpeedData.push(fanSpeed);

                console.log({
                    currentTime,
                    currentT,
                    targetT,
                    currentB,
                    targetB,
                    targetB,
                    fanSpeed
                })

                if (xValues.length > 30) {
                    xValues.shift();
                    nozzempData.shift();
                    nozzempTargerData.shift()
                    bedTempData.shift()
                    bedTempTargetData.shift()
                    fanSpeedData.shift();

                }

                printerTempChart.update();



            } else {
                console.error("Failed to parse the input");
                return null;
            }
        }


        Console_array = [];
        Console_max_size = 20;

        var connection = new WebSocket('ws://' + window.location.hostname + ':81/');

        connection.onopen = function () {
            console.log('Connected to WebSocket');
        };

        connection.onerror = function (error) {
            console.log('WebSocket Error ', error);
        };

        connection.onmessage = function (e) {
            console.log("message received: " + e.data);
            console.log(parseSerial(e.data));
            //parse data

            elem = document.createElement('div');
            elem.innerText = e.data;
            Console_array.push(elem);
            document.getElementById('scroll-container').appendChild(elem);

            if (isAutoScrolling) {
                console.log("scrolling");
                scrollContainer.scrollTop = scrollContainer.scrollHeight;
            }

            if (Console_array.length > Console_max_size) Console_array.pop();

        };

        connection.onclose = function () {
            console.log('WebSocket connection closed');
        };
    </script>




</body>

</html>