<!DOCTYPE html><html lang="en"><head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <style>:root{ --bg-entry-dark: #151d2b; --bg-entry-light: #1f2333; --bg-entry-selected: #053846; --bg-entry-hover: #133548; --bg-bar: #182030; --fg-normal: #d1dae3; --fg-dir: #3dade8; --border-normal: #474f5d;}*{ min-width: 0;}*::-webkit-scrollbar { width: 5px; background: transparent; border-radius: 3px; height: 6px;}*::-webkit-scrollbar-thumb { background: transparent; }*:hover::-webkit-scrollbar-thumb { background: grey; }@keyframes scrollbarFadeIn { 0% { opacity: 1; } 100% { opacity: 0; }}@keyframes scrollbarFadeOut { 0% { opacity: 0; } 100% { opacity: 1; }}p{ margin: 0px; margin-right: 10px;}html{ max-height: 100vh; max-width: 100vw; border-color: var(--border-normal); color: var(--fg-normal);}body{ margin: 0px; padding: 0px; width: 100vw; height: 100vh; max-height: 100vh; background-color: var(--bg-bar)}.unstyled-button{ all: unset; display: inline-block; padding: 10px 20px; margin: 5px; text-align: center; cursor: pointer; font-size: 16px;}.directory-setting-seperator{ display: flex;}.bar{ background-color: var(--bg-bar);}.status-bar{ height: calc(40% - 1px); border-width: 0px 0px 1px 0px; border-style: solid; border-color: var(--border-normal); display: flex; flex-flow: row; overflow-y: scroll; overflow-x: clip;}.dir-view{ height: 100%; width: 60%; max-height: 100%;}.dirent{ width: 100%; height: 2em; display: flex; flex-flow: row; align-items: center;}.dir-files{ width: 100%; height: 60%; overflow: scroll; overflow-x: hidden; background-color: var(--bg-bar);}.dirent:nth-child(even){ background-color: var(--bg-entry-dark);}.dirent:nth-child(odd){ background-color: var(--bg-entry-light);}.dirent:hover{ background-color: var(--bg-entry-hover) !important;}.dir-selected-file{ background-color: var(--bg-entry-selected);}.dirent-item{ display: flex; flex-direction: row; align-items: center; height: 100%;}.dirent-item:hover{ cursor: pointer;}.dirent-item:first-child{ width: 100%; overflow-x: auto; overflow-y: hidden; white-space: nowrap; padding-left: 0em; transition: padding-left 2s; transition-timing-function: cubic-bezier(0,1.23,0,.92);}.dirent-item:first-child:hover{ padding-left: 1em; transition: padding-left 2s; transition-timing-function: cubic-bezier(0,1.23,0,.92);}.dirent-item:last-child{ margin-right: 1em;}.dirent-item:nth-child(n + 0){ margin-left: 1em;}.dirent-image{ min-width: 2em; height: 100%; transition: transform 0.3s; transition-timing-function: cubic-bezier(1,.82,0,1.3);}.dirent-image:hover{ transform: rotate(35deg); transition: transform 0.3s; transition-timing-function: cubic-bezier(1,.82,0,1.3);}.dirent-dir{ color: var(--fg-dir);}.dir-pwd{ border-radius: 0px; height: calc(2em - 1px); background-color: var(--bg-bar) !important; border-color: var(--border-normal); border-width: 0px 0px 1px 0px; border-style: solid; display: flex; align-items: center;}.dir-pwd-item{ display: flex; flex-direction: row; align-items: center; height: 100%; margin-left: 1em;}.new-dir-item{ display: flex; flex-direction: row; align-items: center; height: 100%; margin-left: 1em;}.new-dir-textfield { height: calc(1em + 6px); background-color: inherit; outline: none !important; color: var(--fg-normal); padding: 0px; padding-left: 0.5em; padding-right: 0.5em; border: none;}.new-dir-textfield:focus{ border: white solid; border-width: 0px 0px 1px 0px;}.file-sync-wrong{ color: red;}.settings-bar{ cursor: default; background-color: var(--bg-bar) !important; height: 100%; width: 100%; overflow-y: scroll; overflow-x: hidden;}.status-item{ height: 100%; width: 100%; cursor: default; background-color: var(--bg-bar) !important; overflow-y: auto;}.resize-handle{ display: inline-block; cursor: ew-resize; padding-right: 8px; background-color: var(--bg-bar); border-color: var(--border-normal); border-width: 0px 1px 0px 0px; border-style: solid; width: 33.33vw; height: 100%;}.resize-handle:last-child{ cursor: default; background-color: var(--bg-bar); border-color: var(--border-normal); border-width: 0px 0px 0px 0px; border-style: none;}.resize-handle-setting{ cursor: ew-resize; padding-left: 8px; border-color: var(--border-normal); border-width: 0px 0px 0px 1px; border-style: solid; width: 20%;}.cmd_controls { position: absolute; top: 0; width: 100%; height: 20px; background: #151d2b; border-bottom: 1px solid #ccc; z-index: 10;}#scroll-container { width: 100%; height: 100%; overflow-y: auto; box-sizing: border-box;}#resume-button{ color: white;}#resume-button:hover{ color: rgb(0, 17, 255);}.setting{ display: flex; margin-top: 10px;}.setting { display: block; position: relative; padding-left: 35px; margin-bottom: 12px; cursor: pointer; font-size: 22px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .setting input { position: absolute; opacity: 0; cursor: pointer; height: 0; width: 0; } .checkmark { position: absolute; top: 0; left: 0; height: 25px; width: 25px; background-color: #eee; } .setting:hover input ~ .checkmark { background-color: #ccc; } .setting input:checked ~ .checkmark { background-color: #2196F3; } .checkmark:after { content: ""; position: absolute; display: none; } .setting input:checked ~ .checkmark:after { display: block; } .setting .checkmark:after { left: 9px; top: 5px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; -webkit-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); }</style> <title>Interface</title></head><body id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" onload="files(); getSettings();"> <script> function xhrFetch(url, options) { options = options || {}; return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); xhr.open(options.method || 'GET', url); if (options.headers) { for (var key in options.headers) { if (options.headers.hasOwnProperty(key)) { xhr.setRequestHeader(key, options.headers[key]); } } } if (options.responseType) { xhr.responseType = options.responseType; } xhr.onload = function () { if (xhr.status >= 200 && xhr.status < 300) { resolve({ ok: true, status: xhr.status, statusText: xhr.statusText, json: function () { return Promise.resolve(JSON.parse(xhr.responseText)); }, text: function () { return Promise.resolve(xhr.responseText); } }); } else { reject(new Error('HTTP Error: ' + xhr.status)); } }; xhr.onerror = function () { reject(new Error('Network Error')); }; xhr.send(options.body || null); }); } </script> <script> function clipboard(el) { navigator.clipboard.writeText(el.innerText).then(function () { console.log('Async: Copying to clipboard was successful!'); }, function (err) { console.error('Async: Could not copy text: ', err); }); } function remove(filename) { path = cwd + filename; xhrFetch(`/fm/remove/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`File '${path}' removed successfuly :3`) else console.log(`Failed to remove file '${path}'`) files(); }) } function mkdir(dirname) { path = cwd + dirname; xhrFetch(`/fm/mkdir/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`) else console.log(`Failed to make directory '${path}'`) files(); }) } function printFile(dirname) { path = cwd + dirname; console.log("kek"); xhrFetch(`/device/print/?path=${path}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (resp) { if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`) else console.log(`Failed to make directory '${path}'`) files(); }) } function chdir(name) { oldcwd = cwd; cde = document.getElementById("cwd"); cwd += name; files() .catch(function (err) { console.error("error changing directory to: ", cwd); console.log("reverting back to: ", oldcwd); cwd = oldcwd; cde.innerText = cwd; }); cde.innerText = cwd; } function chdir_back() { if (cwd == "/") return; oldcwd = cwd; cde = document.getElementById("cwd"); len = cwd.length - 2; cwd = cwd.substring(0, cwd.lastIndexOf('/', len)); if (cwd.length == 0) cwd = "/"; console.log("changing directory to", cwd); files() .catch(function (err) { console.error("error changing directory to: ", cwd); console.log("reverting back to: ", oldcwd); cwd = oldcwd; cde.innerText = cwd; }); cde.innerText = cwd; } function file_on_click(el) { if (el.getAttribute("isDirectory") == "true") chdir(el.innerText); else return clipboard(el); } cwd = "/"; const dirent_item = "dirent-item "; function create_file_element(filename) { dirent = document.createElement("div"); dirent.setAttribute("class", "dirent"); filesize = ""; isDirectory = (filename[filename.length - 1] == '/'); { el = document.createElement("div"); classes = dirent_item; if (isDirectory) classes += "dirent-dir "; if (!isDirectory) { filesize = filename.substring(filename.lastIndexOf("_") + 1); filename = filename.substring(0, filename.lastIndexOf("_")); } el.setAttribute("isDirectory", isDirectory); el.setAttribute("onclick", "file_on_click(this)"); el.setAttribute("class", classes); el.appendChild(document.createTextNode(filename)); dirent.appendChild(el); } { classes = dirent_item + "dirent-image "; if (!isDirectory) { el = document.createElement("a"); el.setAttribute("class", classes); el.setAttribute("href", `/fm/downloadFile/?filename=${filename}`); el.setAttribute('download', ''); el.appendChild(document.createTextNode("DW")); dirent.appendChild(el); } { el = document.createElement("div"); el.setAttribute("class", classes); el.appendChild(document.createTextNode("PR")); el.setAttribute("onclick", `printFile("${filename}")`); dirent.appendChild(el); } { el = document.createElement("div"); el.setAttribute("class", classes); el.setAttribute("onclick", `remove("${filename}")`); el.appendChild(document.createTextNode("RM")); dirent.appendChild(el); } } return dirent; } const rotate_rps = 0.5; const rotate_ups = 20; function rotate_file_load_icon() { fsi_el = document.getElementById("file-sync-icon"); angle = 25; increment = (360 * rotate_rps) / rotate_ups; return setInterval(function () { fsi_el.setAttribute("style", `transform: rotate(${angle}deg);`); angle += increment; }, 1000 / 20) } interval_id = 0; function stop_file_load_icon(interval_id) { fsi_el = document.getElementById("file-sync-icon"); fsi_el.setAttribute("style", ''); clearInterval(interval_id); } wrong_timeout_id = null; function set_wrong() { const wrong_class = "file-sync-wrong"; element = document.getElementById("file-sync-icon"); element.classList.add(wrong_class); if (wrong_timeout_id != null) { clearTimeout(wrong_timeout_id); wrong_timeout_id = null; } wrong_timeout_id = setTimeout(function () { wrong_timeout_id = null; element.classList.remove(wrong_class); }, 5000) } function refresh_files(js) { df = document.getElementById("Directory Files"); df.innerHTML = ""; js.forEach(function (element) { console.log(element); e = create_file_element(element); df.appendChild(e); }); stop_file_load_icon(interval_id); } function files() { document.getElementById('fetch').textContent = "listing"; return new Promise(function (resolve, reject) { interval_id = rotate_file_load_icon(); xhrFetch(`/fm/ls/?path=${cwd}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (r) { return r.json(); }) .then(function (js) { return refresh_files(js) }) .catch(function (err) { document.getElementById('fetch').textContent = "error: " + err; console.error(err); set_wrong(); stop_file_load_icon(interval_id); reject(err); }); }) } function upload_file(file) { console.log(`uploading file: '${file.name}' to path '${cwd}'`); const formData = new FormData(); formData.append("file", file); xhrFetch(`/fm/uploadFile/?path=${cwd}`, { method: "POST", body: formData }).then(function (respz) { console.log(respz); files(); }).catch(function (err) { console.error(err) }); } function dropHandler(ev) { console.log("File(s) dropped", ev); ev.preventDefault(); if (ev.dataTransfer.items) { [...ev.dataTransfer.items].forEach(function (item, i) { if (item.kind === "file") { upload_file(item.getAsFile()); } }); } else { [...ev.dataTransfer.files].forEach(function (file, i) { upload_file(file); }); } } function dragOverHandler(ev) { console.log("File(s) in drop zone", ev); ev.preventDefault(); } dir_settings_percent = 80; dir_status_percent = 80; function refresh_dir_status() { dv = document.getElementById("dir-set-sep"); st = document.getElementById("Status Bar"); dv.setAttribute("style", `width: ${dir_status_percent}%;`); st.setAttribute("style", `width: ${100-dir_status_percent}%;`); } function resize_dir_stat(ev) { function update(ev1) { dir_status_percent = 100 * ev1.clientY / document.body.clientHeight; if (dir_status_percent < 1) { dir_status_percent = 1; } else if (dir_status_percent > 99) { dir_status_percent = 99; } refresh_dir_status(); } function updateFinal(ev1) { update(ev1); document.removeEventListener("mouseup", updateFinal); document.removeEventListener("mousemove", update); } document.addEventListener("mouseup", updateFinal); document.addEventListener("mousemove", update); } function refresh_dir_set() { dv = document.getElementById("Directory View"); sc = document.getElementById("Settings Column Resizer"); dv.setAttribute("style", `width: ${dir_settings_percent}%;`); sc.setAttribute("style", `width: ${100-dir_settings_percent}%;`); } function resize_dir_set(ev) { dss = document.getElementById("dir-set-sep"); pos_element = document.getElementById("Settings Column Resizer"); rect = pos_element.getBoundingClientRect(); clientX = ev.clientX || (ev.touches && ev.touches[0].clientX); if (!clientX || clientX < rect.left - 5 || clientX > rect.left + 5) { console.log("Cursor/touch not near the resizable line"); return; } function update(ev1) { currentX = ev1.clientX || (ev1.touches && ev1.touches[0].clientX); if (!currentX) return; dir_settings_percent = (100 * currentX) / dss.clientWidth; dir_settings_percent = Math.max(1, Math.min(dir_settings_percent, 99)); refresh_dir_set(); } function updateFinal(ev1) { update(ev1); document.removeEventListener("mouseup", updateFinal); document.removeEventListener("mousemove", update); } document.addEventListener("mouseup", updateFinal); document.addEventListener("mousemove", update); document.addEventListener("touchend", updateFinal); document.addEventListener("touchmove", update); } document.getElementById("Settings Column Resizer").addEventListener("mousedown", resize_dir_set); document.getElementById("Settings Column Resizer").addEventListener("touchstart", resize_dir_set); bars = [] window.addEventListener("load", function () { console.log("loaded"); sb = document.getElementById("Status Bar"); width = sb.clientWidth; inc = width / sb.children.length; console.log(width, inc, sb); for (index = 0; index < sb.children.length; index++) { const element = sb.children[index]; element.setAttribute("style", `width: ${inc}px;`); if (index != 0) { bars.push(inc * index); } } refresh_dir_set(); files(); }) function index_of_element(e) { const arr = e.parentElement.children; for (index = 0; index < arr.length; index++) { if (arr[index] == e) return index; } return null; } function refresh_bars() { sb = document.getElementById("Status Bar"); total = 0; last = 0; for (index = 0; index < bars.length; index++) { const element = sb.children[index]; const bar = bars[index]; console.log("bar:", bar); console.log("bar-style", `width: ${bar}px;`); element.setAttribute("style", `width: ${bar-total}px;`); total += bar; if (index == bars.length - 1) { last = bar; } } sb.children[sb.children.length - 1].setAttribute("style", `width: ${sb.clientWidth-last}px;`); } bar_resize_ongoing = false; function resize_vertical_bars(ev, index) { console.log(ev); if (ev.clientX > bars[index] + 32 || ev.clientX < bars[index] - 32) return; bar_resize_ongoing = true; ev.preventDefault(); function resize_bar(cursor_x) { if (index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) { cursor_x = bars[index + 1] - 8; } if (index >= 1 && bars[index - 1] + 8 > cursor_x) { cursor_x = bars[index - 1] + 8; } sbw = document.getElementById("Status Bar").clientWidth - 8; if (cursor_x > sbw) { cursor_x = sbw; } if (cursor_x < 8) { cursor_x = 8; } if ((index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) || index >= 1 && bars[index - 1] + 8 > cursor_x) { return; } bars[index] = cursor_x; } function intermission_reszie(ev1) { resize_bar(ev1.clientX); refresh_bars(); } function final_resize(ev1) { resize_bar(ev1.clientX); refresh_bars(); document.removeEventListener("mouseup", final_resize); document.removeEventListener("mousemove", intermission_reszie); bar_resize_ongoing = false; }; document.addEventListener("mouseup", final_resize); document.addEventListener("mousemove", intermission_reszie); } function begin_mkdir() { cd = document.getElementById("Directory Files"); const tf_placeholder = "Leave Empty to cancel"; const tf_name = "new-dir-name"; div = document.createElement('div'); div.id = "new-dir-dirent"; div.classList.add("dirent"); text_field_label = document.createElement('label'); text_field_label.setAttribute("for", tf_name); text_field_label.classList.add("new-dir-item"); text_field_label.innerText = "Directory Name"; text_field = document.createElement('input'); text_field.classList.add("new-dir-item", "new-dir-textfield"); text_field.setAttribute("type", "text"); text_field.setAttribute("name", tf_name); text_field.setAttribute("id", tf_name); text_field.setAttribute("placeholder", tf_placeholder); div.appendChild(text_field_label); div.appendChild(text_field); cd.appendChild(div); text_field.addEventListener("focusout", function (ev) { dirname = text_field.value; text_field_label.remove(); text_field.remove(); div.remove(); mkdir(dirname); }) text_field.focus(); } function sendBooleanSetting(pos, state) { xhrFetch(`/config/setDynamicConfig/?config=${pos}&status=${state}`, { method: 'GET', headers: { 'Content-Type': 'application/text' } }).then(function (respz) { console.log(respz); files(); }).catch(function (err) { console.error(err) }); } </script> <div id="Status Bar" class="bar status-bar"> <div id="1" class="resize-handle" onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}"> <div class="status-item"> <div> <p id="fetch">Check Fetch Support</p> </div> </div> </div> <div id="1" class="resize-handle" onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}"> <div class="status-item"> <br> <canvas id="temperatures" style="width:100%;max-width:600px"></canvas> </div> </div> <div id="3" class="resize-handle"> <div class="status-item" style="position: relative;"> <div class="cmd_controls"> <div id="resume-button">Scroll</div> </div> <div id="scroll-container"></div> </div> </div> </div> <div id="dir-set-sep" class="directory-setting-seperator"> <div id="Directory View" class="dir-view"> <div id="Current Directory" class="dir-pwd dirent"> <button id="back" class="dir-pwd-item dirent-image unstyled-button" onclick="chdir_back()">BK</button> <button id="mkdir" class="dir-pwd-item dirent-image unstyled-button" onclick="mkdir()">MD</button> <button id="file-sync-icon" class="dir-pwd-item dirent-image unstyled-button" onclick="files()">RF</button> <div id="cwd" class="dir-pwd-item">/</div> </div> <div id="Directory Files" class="dir-files"> </div> </div> <div id="Settings Column Resizer" class="resize-handle-setting" onmousedown="resize_dir_set(event)"> <div id="Settings Column" class="bar settings-bar"> <div>Settings. Hover for more information</div> <br> <div>esp configuration</div> <label class="setting"> <input type="checkbox" id="debugViaSerial" name="debugViaSerial" value="0" onchange="sendBooleanSetting(0, +this.checked)" /> <div title="esp sends debugging messages via serial. If you dont have pc connected to usb output of esp disable this."> debug via serial</div> <span class="checkmark"></span> </label> <label class="setting"> <input type="checkbox" id="debugViaWeb" name="debugViaWeb" value="coding" onchange="sendBooleanSetting(1, +this.checked)" /> <div title="esp sends debugging log via socket to web client.">debug via web interface</div> <span class="checkmark"></span> </label> <label class="setting"> <input type="checkbox" id="showSentCommands" name="showSentCommands" value="coding" onchange="sendBooleanSetting(2, +this.checked)" /> <div title="When enabled esp is going to log sent commands via serial and/or socket">show sent commands</div> <span class="checkmark"></span> </label> <label class="setting"> <input type="checkbox" id="queueStatus" name="queueStatus" value="coding" onchange="sendBooleanSetting(3, + this.checked)" /> <div title="Shows how many commands in queue">show queue status</div> <span class="checkmark"></span> </label> <label class="setting"> <input type="checkbox" id="showFailedComamnds" name="showFailedComamnds" value="coding" onchange="sendBooleanSetting(4, + this.checked)" /> <div title="">show failed commands</div> <span class="checkmark"></span> </label> </div> </div> </div> <script> function getSettings() { xhrFetch('/config/getDynamicConfig/', { method: 'GET', headers: { 'Content-Type': 'application/text' } }) .then(function (response) { return response.text(); }) .then(function (data) { console.log(typeof(data)); reversed = data.split('').reverse().join(''); console.log(reversed); return reversed; }) .then(function(config){ document.getElementById("debugViaSerial").checked = !!config[0]; document.getElementById("debugViaWeb").checked = !!config[1]; document.getElementById("showSentCommands").checked = !!config[2]; document.getElementById("queueStatus").checked = !!config[3]; document.getElementById("showFailedComamnds").checked = !!config[4]; }) } </script> <script> var scrollContainer = document.getElementById('scroll-container'); var resumeButton = document.getElementById('resume-button'); var isAutoScrolling = true; var userInteracted = false; scrollContainer.addEventListener('scroll', function () { if (!userInteracted && scrollContainer.scrollTop + scrollContainer.clientHeight < scrollContainer .scrollHeight) { isAutoScrolling = false; userInteracted = true; } }); resumeButton.addEventListener('click', function () { console.log("should scroll"); isAutoScrolling = true; userInteracted = false; scrollContainer.scrollTop = scrollContainer.scrollHeight; }); </script> <script src="https: <script> const xValues = []; const nozzempData = []; const nozzempTargerData = []; const bedTempData = []; const bedTempTargetData = []; const fanSpeedData = []; const printerTempChart = new Chart("temperatures", { type: "line", data: { labels: xValues, datasets: [{ data: nozzempData, borderColor: "#BD2D03", fill: false }, { data: nozzempTargerData, borderColor: "#F68462", fill: false }, { data: bedTempData, borderColor: "#107C99", fill: false }, { data: bedTempTargetData, borderColor: "#22C3EF", fill: false }, { data: fanSpeedData, borderColor: "#DDA512", fill: false }, ] }, options: { legend: { display: false } } }); </script> <script> function parseSerial(data) { if (typeof data !== 'string' || !data.includes("T:") || !data.includes("B:") || !data.includes("FAN0@")) { console.log(typeof data); console.log(data.includes("T:")); console.log(data.includes("FAN0@")); console.error("Invalid input data"); return; } const regex = /T:([\d.]+)\s+\/([\d.]+).*B:([\d.]+)\s+\/([\d.]+).*FAN0@:(\d+)/; const match = data.match(regex); if (match) { const currentT = parseFloat(match[1]); const targetT = parseFloat(match[2]); const currentB = parseFloat(match[3]); const targetB = parseFloat(match[4]); const fanSpeed = parseInt(match[5], 10); const currentTime = xValues.length > 0 ? xValues[xValues.length - 1] + 1 : 0; xValues.push(currentTime); nozzempData.push(currentT); nozzempTargerData.push(targetT); bedTempData.push(currentB); bedTempTargetData.push(targetB); fanSpeedData.push(fanSpeed); console.log({ currentTime, currentT, targetT, currentB, targetB, targetB, fanSpeed }) if (xValues.length > 30) { xValues.shift(); nozzempData.shift(); nozzempTargerData.shift() bedTempData.shift() bedTempTargetData.shift() fanSpeedData.shift(); } printerTempChart.update(); } else { console.error("Failed to parse the input"); return null; } } Console_array = []; Console_max_size = 20; var connection = new WebSocket('ws: connection.onopen = function () { console.log('Connected to WebSocket'); }; connection.onerror = function (error) { console.log('WebSocket Error ', error); }; connection.onmessage = function (e) { console.log("message received: " + e.data); console.log(parseSerial(e.data)); elem = document.createElement('div'); elem.innerText = e.data; Console_array.push(elem); document.getElementById('scroll-container').appendChild(elem); if (isAutoScrolling) { console.log("scrolling"); scrollContainer.scrollTop = scrollContainer.scrollHeight; } if (Console_array.length > Console_max_size) Console_array.pop(); }; connection.onclose = function () { console.log('WebSocket connection closed'); }; </script></body></html>