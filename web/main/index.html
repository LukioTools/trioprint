<!--
 Copyright (c) <2025> <Vili Kervinen>
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:
 
 The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
    
    <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="index.css">
    <link rel="stylesheet" href="progress_bar.css">
    <title>Interface</title>

</head>

<body id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" onload="files(); getSettings();">


    <script>
        function xhrFetch(url, options) {
            options = options || {};
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();

                // Set up the method and URL
                xhr.open(options.method || 'GET', url);

                // Set request headers
                if (options.headers) {
                    for (var key in options.headers) {
                        if (options.headers.hasOwnProperty(key)) {
                            xhr.setRequestHeader(key, options.headers[key]);
                        }
                    }
                }

                // Set response type if defined in options
                if (options.responseType) {
                    xhr.responseType = options.responseType;
                }

                // Track upload progress
                if (xhr.upload && options.onProgress) {
                    xhr.upload.onprogress = function (event) {
                        if (event.lengthComputable) {
                            const progress = (event.loaded / event.total) * 100; // Percentage
                            options.onProgress(progress, event.loaded, event.total);
                        }
                    };
                }

                // Handle the response
                xhr.onload = function () {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve({
                            ok: true,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: function () {
                                return Promise.resolve(JSON.parse(xhr.responseText));
                            },
                            text: function () {
                                return Promise.resolve(xhr.responseText);
                            }
                        });
                    } else {
                        reject(new Error('HTTP Error: ' + xhr.status));
                    }
                };

                // Handle errors
                xhr.onerror = function () {
                    reject(new Error('Network Error'));
                };

                // Send the request with the provided body (if any)
                xhr.send(options.body || null);
            });
        }
    </script>

    <!--file view & navigation-->
    <script>
        function clipboard(el) {
            navigator.clipboard.writeText(el.innerText).then(function () {
                console.log('Async: Copying to clipboard was successful!');
            }, function (err) {
                console.error('Async: Could not copy text: ', err);
            });
        }

        function remove(filename) {
            path = cwd + filename;
            xhrFetch(`/fm/remove/?path=${path}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`File '${path}' removed successfuly :3`)
                    else console.log(`Failed to remove file '${path}'`)
                    files();
                })
        }

        function mkdir(dirname) {
            path = cwd + dirname;
            xhrFetch(`/fm/mkdir/?path=${path}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`)
                    else console.log(`Failed to make directory '${path}'`)
                    files();
                })
        }

        function printFile(dirname) {
            path = cwd + dirname;
            console.log("kek");
            xhrFetch(`/device/print/?path=${path}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`Directory '${path}' created successfuly :3`)
                    else console.log(`Failed to make directory '${path}'`)
                    files();
                })
        }

        function chdir(name) {
            oldcwd = cwd;
            cde = document.getElementById("cwd");
            cwd += name;
            files()
                .catch(function (err) {
                    console.error("error changing directory to: ", cwd);
                    console.log("reverting back to: ", oldcwd);
                    cwd = oldcwd;
                    cde.innerText = cwd;
                });
            cde.innerText = cwd;
        }

        function chdir_back() {
            if (cwd == "/") return;
            oldcwd = cwd;
            cde = document.getElementById("cwd");
            len = cwd.length - 2;
            cwd = cwd.substring(0, cwd.lastIndexOf('/', len));
            if (cwd.length == 0) cwd = "/";
            console.log("changing directory to", cwd);
            files()
                .catch(function (err) {
                    console.error("error changing directory to: ", cwd);
                    console.log("reverting back to: ", oldcwd);
                    cwd = oldcwd;
                    cde.innerText = cwd;
                });
            cde.innerText = cwd;
        }

        function file_on_click(el) {
            if (el.getAttribute("isDirectory") == "true") chdir(el.innerText);
            else return clipboard(el);
        }

        cwd = "/";
        const dirent_item = "dirent-item ";
        //when the icons are ready, insert them here
        /**
         * @param filename {string}
         * */
        function create_file_element(filename) {

            dirent = document.createElement("div");
            dirent.setAttribute("class", "dirent");
            filesize = "";
            isDirectory = (filename[filename.length - 1] == '/'); { // file
                el = document.createElement("div");
                classes = dirent_item;

                if (isDirectory) classes += "dirent-dir ";
                if (!isDirectory) {
                    filesize = filename.substring(filename.lastIndexOf("_") + 1);
                    filename = filename.substring(0, filename.lastIndexOf("_"));
                }

                el.setAttribute("isDirectory", isDirectory);
                el.setAttribute("onclick", "file_on_click(this)");
                el.setAttribute("class", classes);

                el.appendChild(document.createTextNode(filename));
                dirent.appendChild(el);
            } { //buttons
                classes = dirent_item + "dirent-image ";
                if (!isDirectory) {
                    {
                        //size

                        if (filesize != undefined && filesize != 0) {

                            //download
                            el = document.createElement("a");
                            el.setAttribute("class", classes);
                            el.setAttribute("style", "margin-right: 2em; margin-left: 1em; white-space: nowrap;");

                            //el.setAttribute("onclick", `download("${filename}")`);

                            //file size calculator
                            const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
                            const factor = 1024; // Conversion factor

                            // Determine the unit to use
                            const unitIndex = Math.floor(Math.log(filesize) / Math.log(factor));
                            const fileSize = filesize / Math.pow(factor, unitIndex);

                            el.appendChild(document.createTextNode(`${fileSize.toFixed(2)} ${units[unitIndex]}`));
                        } else {
                            el = document.createElement("a");
                            el.setAttribute("class", classes);
                            el.setAttribute("style", "margin-right: 2em; margin-left: 1em; white-space: nowrap;");
                            el.appendChild(document.createTextNode(`0 bytes`));
                        }
                        dirent.appendChild(el);

                    } {
                        //download
                        el = document.createElement("a");
                        el.setAttribute("class", classes);
                        //el.setAttribute("onclick", `download("${filename}")`);
                        el.setAttribute("href", `/fm/downloadFile/?filename=${filename}`);
                        el.setAttribute('download', '');
                        el.appendChild(document.createTextNode("DW"));
                        dirent.appendChild(el);
                    } {
                        //print
                        el = document.createElement("div");
                        el.setAttribute("class", classes);
                        el.appendChild(document.createTextNode("PR"));
                        el.setAttribute("onclick", `printFile("${filename}")`);
                        dirent.appendChild(el);
                    }
                } { //remove
                    el = document.createElement("div");
                    el.setAttribute("class", classes);
                    el.setAttribute("onclick", `remove("${filename}")`);
                    el.appendChild(document.createTextNode("RM"));
                    dirent.appendChild(el);
                }
            }
            return dirent;
        }

        const rotate_rps = 0.5;
        const rotate_ups = 20;

        function rotate_file_load_icon() {
            fsi_el = document.getElementById("file-sync-icon");
            angle = 25;
            increment = (360 * rotate_rps) / rotate_ups;
            int = setInterval(function () {
                fsi_el.setAttribute("style", `transform: rotate(${angle}deg);`);
                angle += increment;
            }, 1000 / 20)
            return int;
        }

        interval_id = [];

        function stop_file_load_icon() {
            fsi_el = document.getElementById("file-sync-icon");
            interval_id.forEach(function (item, index, arr) {
                window.clearInterval(item);
                arr.splice(index, 1);
            })
            fsi_el.setAttribute("style", '');
        }

        wrong_timeout_id = null;

        function set_wrong() {
            const wrong_class = "file-sync-wrong";
            element = document.getElementById("file-sync-icon");
            element.classList.add(wrong_class);
            if (wrong_timeout_id != null) {
                clearTimeout(wrong_timeout_id);
                wrong_timeout_id = null;
            }
            wrong_timeout_id = setTimeout(function () {
                wrong_timeout_id = null;
                element.classList.remove(wrong_class);
            }, 5000)
        }

        function refresh_files(js) {
            df = document.getElementById("Directory Files");

            df.innerHTML = "";

            //df.replaceChildren();
            js.forEach(function (element) {
                e = create_file_element(element);
                df.appendChild(e);
            });

            stop_file_load_icon();
        }

        function files() {

            return new Promise(function (resolve, reject) {
                interval_id.push(rotate_file_load_icon());
                xhrFetch(`/fm/ls/?path=${cwd}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                    .then(function (r) {
                        return r.json();
                    })
                    .then(function (js) {
                        return refresh_files(js)
                    })
                    .catch(function (err) {
                        console.error(err);
                        set_wrong();
                        stop_file_load_icon();

                        reject(err);
                    });
            })
        }

        /**
         * @param file {Object}.
         * @param file.lastModified {number}.
         * @param file.name {string} The name of the file.
         * @param file.size {number} The size of the file.
         * @param file.type {string} The mimetype of the file.
         * @param file.webkitRelativePath {string | ""} The rel-path of the file.
         */
        function upload_file(file) {
            console.log(`uploading file: '${file.name}' to path '${cwd}'`);
            const formData = new FormData();
            formData.append("file", file);
            xhrFetch(`/fm/uploadFile/?path=${cwd}`, {
                method: "POST",
                body: formData,
                onProgress: function (progress, loaded, total) {
                    console.log(`Progress: ${progress.toFixed(2)}% (${loaded}/${total} bytes)`);
                    updateProgress(progress.toFixed(2), "UPLOAD STATUS");
                }
            }).then(function (respz) {
                console.log(respz);
                files();
            }).catch(function (err) {
                console.error(err)
            });
        }

        function dropHandler(ev) {
            console.log("File(s) dropped", ev);
            ev.preventDefault();
            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach(function (item, i) {
                    // If dropped items aren't files, reject them
                    if (item.kind === "file") {
                        upload_file(item.getAsFile());
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach(function (file, i) {
                    upload_file(file);
                });
            }
        }

        function dragOverHandler(ev) {
            console.log("File(s) in drop zone", ev);
            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();
            //document.getElementById("drop-zone").setAttribute("")
        }

        dir_settings_percent = 80;
        dir_status_percent = 80;

        function refresh_dir_status() {
            dv = document.getElementById("dir-set-sep");
            st = document.getElementById("Status Bar");
            dv.setAttribute("style", `width: ${dir_status_percent}%;`);
            st.setAttribute("style", `width: ${100 - dir_status_percent}%;`);
        }

        function refresh_dir_set() {
            dv = document.getElementById("Directory View");
            sc = document.getElementById("Settings Column Resizer");
            dv.setAttribute("style", `width: ${dir_settings_percent}%;`);
            sc.setAttribute("style", `width: ${100 - dir_settings_percent}%;`);
        }


        function resize_dir_set(ev) {
            try {
                dss = document.getElementById("dir-set-sep");
                pos_element = document.getElementById("Settings Column Resizer");
                rect = pos_element.getBoundingClientRect();

                clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX);

                if (!clientX || clientX < rect.left - 15 || clientX > rect.left + 15) {
                    return; // Exit if cursor or touch is not near the resizable line
                }
                ev.preventDefault();

            } catch (err) {
                alert(err);
            }

            function update(ev1) {
                try {
                    // Ensure ev1.clientX or ev1.touches is available
                    currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1
                        .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX);
                    if (!currentX) return;



                    dir_settings_percent = (100 * currentX) / dss.clientWidth;
                    dir_settings_percent = Math.max(1, Math.min(dir_settings_percent, 99)); // Clamp between 1% and 99%
                    refresh_dir_set();
                } catch (err) {
                    alert(err);
                }
            }

            function updateFinal(ev1) {
                update(ev1);
                document.removeEventListener("mouseup", updateFinal);
                document.removeEventListener("mousemove", update);
                document.removeEventListener("touchend", updateFinal);
                document.removeEventListener("touchmove", update);
            }

            document.addEventListener("mouseup", updateFinal);
            document.addEventListener("mousemove", update);
            document.addEventListener("touchend", updateFinal);
            document.addEventListener("touchmove", update);
        }

        var bars = []



        function index_of_element(e) {
            const arr = e.parentElement.children;
            for (index = 0; index < arr.length; index++) {
                if (arr[index] == e) return index;
            }
            return null;
        }

        function refresh_bars() {
            sb = document.getElementById("Status Bar");
            total = 0;
            last = 0;
            for (index = 0; index < bars.length; index++) {
                const element = sb.children[index];
                const bar = bars[index];
                barsize = Math.round(bar);
                element.setAttribute("style", `width: ${barsize - total}px;`);
                total += barsize;
                if (index == bars.length - 1) {
                    last = barsize;
                }
            }
            sb.children[sb.children.length - 1].setAttribute("style", `width: ${sb.clientWidth - last}px;`);
        }

        var bar_resize_ongoing = false;

        function resize_vertical_bars(ev, index) {

            clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX);

            if (!clientX || clientX < bars[index] - 15 || clientX > bars[index] + 15) {
                return; // Exit if cursor or touch is not near the resizable line
            }
            ev.preventDefault();


            bar_resize_ongoing = true;

            function resize_bar(cursor_x) {

                if (index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) {
                    cursor_x = bars[index + 1] - 8;
                }
                if (index >= 1 && bars[index - 1] + 8 > cursor_x) {
                    cursor_x = bars[index - 1] + 8;
                }
                sbw = document.getElementById("Status Bar").clientWidth - 8;
                if (cursor_x > sbw) {
                    cursor_x = sbw;
                }
                if (cursor_x < 8) {
                    cursor_x = 8;
                }
                //idk anymore
                if ((index + 1 < bars.length && bars[index + 1] - 8 < cursor_x) || index >= 1 && bars[index - 1] + 8 >
                    cursor_x) {
                    return;
                }
                bars[index] = cursor_x;
            }

            function intermission_reszie(ev1) {

                currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1
                    .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX);


                resize_bar(currentX);
                refresh_bars();
                resizeTempHandler();
            }

            function final_resize(ev1) {
                currentX = ev1.clientX || (ev1.touches && ev1.touches[0] && ev1.touches[0].clientX) || (ev1
                    .changedTouches && ev1.changedTouches[0] && ev1.changedTouches[0].clientX);

                resize_bar(currentX);
                refresh_bars();
                resizeTempHandler();
                document.removeEventListener("mouseup", final_resize);
                document.removeEventListener("mousemove", intermission_reszie);
                document.removeEventListener("touchend", final_resize);
                document.removeEventListener("touchmove", intermission_reszie);

                bar_resize_ongoing = false;
            };

            document.addEventListener("mouseup", final_resize);
            document.addEventListener("mousemove", intermission_reszie);

            document.addEventListener("touchmove", intermission_reszie);
            document.addEventListener("touchend", final_resize);

        }

        function begin_mkdir() {
            cd = document.getElementById("Directory Files");

            /*
            div id="new-dir-dirent" class="dirent">
                <label for="new-dir-name" class="new-dir-item">Directory Name</label>
                <input class="new-dir-item new-dir-textfield" type="text" name="new-dir-name" id="new-dir-name" placeholder="Leave Empty to cancel">
            </div>
            */
            const tf_placeholder = "Leave Empty to cancel";
            const tf_name = "new-dir-name";

            div = document.createElement('div');
            div.id = "new-dir-dirent";
            div.classList.add("dirent");
            text_field_label = document.createElement('label');
            text_field_label.setAttribute("for", tf_name);
            text_field_label.classList.add("new-dir-item");
            text_field_label.innerText = "Directory Name";
            text_field = document.createElement('input');
            text_field.classList.add("new-dir-item", "new-dir-textfield");
            text_field.setAttribute("type", "text");
            text_field.setAttribute("name", tf_name);
            text_field.setAttribute("id", tf_name);
            text_field.setAttribute("placeholder", tf_placeholder);

            div.appendChild(text_field_label);
            div.appendChild(text_field);

            cd.appendChild(div);

            text_field.addEventListener("focusout", function (ev) {
                dirname = text_field.value;
                text_field_label.remove();
                text_field.remove();
                div.remove();

                mkdir(dirname);
            })
            text_field.focus();
        }

        function sendBooleanSetting(pos, state) {
            xhrFetch(`/config/setDynamicConfig/?type=0&config=${pos}&status=${state}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            }).then(function (respz) { }).catch(function (err) {
                alert("can't save settings: " + err);
                console.error(err)
            });
        }

        // types start from 1 as 0 is reserved for booleans
        function sendCharSetting(type, state) {
            xhrFetch(`/config/setDynamicConfig/?type=${type}&status=${state}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            }).then(function (respz) { }).catch(function (err) {
                alert("can't save settings: " + err);
                console.error(err)
            });
        }
    </script>


    <!-- Progress etc. on the top as a bar -->
    <div id="Status Bar" class="bar status-bar">
        <div id="status-1" class="resize-handle"
            onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}">
            <div class="status-item">
                <div
                    style="display: flex; width: 100%; height: 100%; align-items: center; justify-content: center; flex-direction: column;">
                    <h1 id="Progress type" class="progress-type">print status</h1>
                    <div class="circular-progress-skill">
                        <div id="circular-progress-number"> </div>

                        <svg class="circular-progress-svg" xmlns="http://www.w3.org/2000/svg" version="1.1"
                            width="160px" height="160px">
                            <defs>
                                <linearGradient id="GradientColor">
                                    <stop offset="0%" stop-color="#DA22FF" />
                                    <stop offset="100%" stop-color="#9733EE" />
                                </linearGradient>
                            </defs>
                            <circle id="circular-progress-circle" class="circular-progress-circle" cx="80" cy="80"
                                r="70" stroke-linecap="round" />
                        </svg>
                    </div>
                    <div class="control-button-holder">
                        <button class="control-button" onclick="updateProgress(67)">STOP</button>
                        <button class="control-button EMS" onclick="updateProgress(20)">EMS</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="status-2" class="resize-handle"
            onmousedown="if(!bar_resize_ongoing){resize_vertical_bars(event, index_of_element(this));}">
            <div class="status-item" id="">
                <div style="display: flex; flex-direction: column; align-items: stretch; width: 100%; height: 100%;">
                    <div id="chart-temps-parent-container" style="flex-grow: 1; width: 100%;  height: 100%;">
                        <div id="chart-temps-container" style="position: relative; width: 100%;">
                            <canvas id="temperatures"></canvas>
                        </div>
                        <br>
                        <div>print time: 6h 30 min</div>
                        <div>printer status: offline</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="status-3" class="resize-handle">
            <div class="status-item" style="position: relative;">
                <div class="cmd_controls">
                    <button id="resume-button" class="scroll-button">Scroll</button>
                </div>
                <div id="scroll-container"></div>
            </div>
        </div>
    </div>

    <div id="dir-set-sep" class="directory-setting-seperator">
        <div id="Directory View" class="dir-view">
            <div id="Current Directory" class="dir-pwd dirent">
                <button id="back" class="dir-pwd-item dirent-image unstyled-button" onclick="chdir_back()">BK</button>
                <button id="mkdir" class="dir-pwd-item dirent-image unstyled-button" onclick="mkdir()">MD</button>

                <button id="file-sync-icon" class="dir-pwd-item dirent-image unstyled-button"
                    onclick="files()">RF</button>

                <div class="upload-button-container">
                    <input type="file" id="fileInput" style="display: none;" class="file-input">
                    <button id="fileInputButton" class="dir-pwd-item dirent-image unstyled-button" onclick="document.getElementById('fileInput').click()">Upload File</button>

                </div>



                <div id="cwd" class="dir-pwd-item">/</div>
            </div>
            <div id="Directory Files" class="dir-files">
                <!--
                    <div class="dirent">
                        <div class="dirent-item dirent-dir" isDirectory="true" onclick="file_on_click(this)">directory/</div>
                        <div class="dirent-item dirent-image">DW</div>
                        <div class="dirent-item dirent-image">PR</div>
                        <div class="dirent-item dirent-image">RM</div>
                    </div>
                    <div class="dirent">
                        <div class="dirent-item" onclick="file_on_click(this)">filename</div>
                        <div class="dirent-item dirent-image">DW</div>
                        <div class="dirent-item dirent-image">PR</div>
                        <div class="dirent-item dirent-image">RM</div>
                    </div>
                    <div id="new-dir-dirent" class="dirent">
                        <label for="new-dir-name" class="new-dir-item">Directory Name</label>
                        <input class="new-dir-item new-dir-textfield" type="text" name="new-dir-name" id="new-dir-name" placeholder="Leave Empty to cancel">
                        </div>
                        -->


            </div>
        </div>
        <div id="Settings Column Resizer" class="resize-handle-setting" onmousedown="resize_dir_set(event)">
            <div id="Settings Column" class="bar settings-bar">
                <h4>Settings</h4>
                <p>visit this site <a href="server/config">esp configuration</a></p>

            </div>
        </div>
    </div>

    <!-- circle bar animation -->
    <script>

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('progressContainer').style.display = 'block';
                upload_file(file);
            }
        });

        function progressType(type) {
            const h = document.getElementById("Progress type");
            h.textContent = type;
        }

        function updateProgress(progress, type) {
            progressType(type)
            // Ensure progress is between 0 and 100
            progress = Math.min(Math.max(progress, 0), 100);

            const circle = document.getElementById("circular-progress-circle");
            const progressNumber = document.getElementById("circular-progress-number");

            // Calculate the stroke-dashoffset based on the progress
            const radius = circle.r.baseVal.value;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (progress / 100) * circumference;

            // Set the custom property to control the stroke-dashoffset via CSS
            circle.style.setProperty('--circular-progress-circle-dash', offset);
            circle.classList.add("circular-progress-circle-progress")

            // Update the text to reflect the current progress
            progressNumber.textContent = `${progress}%`;

            // Force reflow to restart the animation
            circle.offsetHeight; // This forces a reflow and re-applies styles
        }
        updateProgress(0, "NO PRINT RUNNING");
    </script>

    <!-- Settings -->
    <script>
        function updateCheckboxState(checkboxId, isChecked) {
            const checkbox = document.getElementById(checkboxId);
            const checkmark = checkbox.nextElementSibling.nextElementSibling;

            // Set the checkbox's checked property
            checkbox.checked = !!(+isChecked);
        }

        function getSettings() {
            xhrFetch('/config/getDynamicConfig/', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/text'
                }
            })
                .then(function (response) {
                    return response.text();
                })
                .then(function (data) {
                    reversed = data.split('').reverse().join('');
                    return reversed;
                })
                .then(function (config) {
                    updateCheckboxState("debugViaSerial", config[0]);
                    updateCheckboxState("debugViaWeb", config[1]);
                    updateCheckboxState("showSentCommands", config[2]);
                    updateCheckboxState("queueStatus", config[3]);
                    updateCheckboxState("showFailedComamnds", config[4]);
                })
        }
    </script>

    <!-- print commands stop/EMS -->
    <script>
        /*
        function emsPrinter(){
            xhrFetch(`/fm/remove/?path=${path}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/text'
                    }
                })
                .then(function (resp) {
                    if (resp.status == 200) console.log(`File '${path}' removed successfuly :3`)
                    else console.log(`Failed to remove file '${path}'`)
                    files();
                })
        }

        function stopprint(){

        }*/
    </script>

    <!--Serial scrolling-->
    <script>
        var scrollContainer = document.getElementById('scroll-container');
        var resumeButton = document.getElementById('resume-button');

        var isAutoScrolling = true;
        var userInteracted = false;

        // Stop scrolling when user interacts
        scrollContainer.addEventListener('scroll', function () {
            if (!userInteracted && scrollContainer.scrollTop + scrollContainer.clientHeight < scrollContainer
                .scrollHeight) {
                isAutoScrolling = false;
                userInteracted = true;
            }
        });

        // Resume scrolling on button press
        resumeButton.addEventListener('click', function () {
            isAutoScrolling = true;
            userInteracted = false;
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>

    <script>
        const parentContainer = document.getElementById('chart-temps-parent-container');
        const chartContainer = document.getElementById('chart-temps-container');
        const canvas = document.getElementById('temperatures');

        aspectRatio = 130 / 260;

        function resizeTempsCanvas() {
            const parentWidth = parentContainer.offsetWidth;
            const parentHeight = parentContainer.offsetHeight;

            // Define desired aspect ratio
            const aspectRatio = 3 / 2; // Width:Height


            canvasWidth = parentWidth;
            canvasHeight = parentWidth / aspectRatio;



            if (canvasHeight > parentHeight) {
                console.log("height limit")
                // If height exceeds the parent, adjust width to maintain aspect ratio
                canvasHeight = parentHeight;
                canvasWidth = parentHeight * aspectRatio;
            }

            console.log(canvasWidth + " : " + canvasHeight)

            // Apply calculated dimensions to the canvas
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            chartContainer.style.width = `${canvasWidth}px`; // Display width
            chartContainer.style.height = `${canvasHeight}px`; // Display height
        }

        const xValues = [];
        const nozzempData = [];
        const nozzempTargerData = [];
        const bedTempData = [];
        const bedTempTargetData = [];
        const fanSpeedData = [];

        const printerTempChart = new Chart("temperatures", {
            type: "line",
            data: {
                labels: xValues,
                datasets: [{
                    data: nozzempData,
                    borderColor: "#BD2D03",
                    fill: false
                },
                {
                    data: nozzempTargerData,
                    borderColor: "#F68462",
                    fill: false
                },
                {
                    data: bedTempData,
                    borderColor: "#107C99",
                    fill: false
                },
                {
                    data: bedTempTargetData,
                    borderColor: "#22C3EF",
                    fill: false
                },
                {
                    data: fanSpeedData,
                    borderColor: "#DDA512",
                    fill: false
                },
                ]
            },
            options: {
                responsive: false,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
                legend: {
                    display: false
                }
            }
        });

        function resizeTempHandler() {
            resizeTempsCanvas();
            printerTempChart.resize();
            printerTempChart.update();
        };

        resizeTempHandler();
    </script>

    <!--serial console-->
    <script>
        function parseSerial(data) {
            // Ensure the input is a string and contains key markers we expect
            if (typeof data !== 'string') return;
            if (data.includes("T:") || data.includes("B:") || data.includes("FAN0@")) {

                // Regular expressions to extract T, B temperatures, and FAN0@ values
                const regex = /T:([\d.]+)\s+\/([\d.]+).*B:([\d.]+)\s+\/([\d.]+).*FAN0@:(\d+)/;

                // Execute the regex on the input string
                const match = data.match(regex);

                if (match) {
                    const currentT = parseFloat(match[1]); // Current T temperature
                    const targetT = parseFloat(match[2]); // Target T temperature
                    const currentB = parseFloat(match[3]); // Current B temperature
                    const targetB = parseFloat(match[4]); // Target B temperature
                    const fanSpeed = parseInt(match[5], 10); // FAN0 speed

                    const currentTime = xValues.length > 0 ? xValues[xValues.length - 1] + 1 : 0;

                    xValues.push(currentTime);
                    nozzempData.push(currentT);
                    nozzempTargerData.push(targetT);
                    bedTempData.push(currentB);
                    bedTempTargetData.push(targetB);
                    fanSpeedData.push(fanSpeed);

                    if (xValues.length > 30) {
                        xValues.shift();
                        nozzempData.shift();
                        nozzempTargerData.shift()
                        bedTempData.shift()
                        bedTempTargetData.shift()
                        fanSpeedData.shift();

                    }

                    printerTempChart.update();



                } else {
                    return null;
                }
            } else if (data.includes("commands completed:")) {
                const regex = /(\d+)\/(\d+)/;
                const match = data.match(regex);

                if (match) {
                    const completed = parseInt(match[1], 10);
                    const total = parseInt(match[2], 10);
                    console.log("completed: " + completed / total + "%")
                    updateProgress(Math.round((completed / total) * 100), "PRINT STATUS");
                }

            } else if (data.includes("Clearing root cache...")) {
                window.location.reload();
            }

        }

        Console_array = [];
        Console_max_size = 20;

        var connection = new WebSocket('ws://' + window.location.hostname + ':81/');

        connection.onopen = function () {
            console.log('Connected to WebSocket');
        };

        connection.onerror = function (error) {
            console.log('WebSocket Error ', error);
        };

        connection.onmessage = function (e) {

            parseSerial(e.data);

            elem = document.createElement('div');
            elem.innerText = e.data;
            Console_array.push(elem);
            document.getElementById('scroll-container').appendChild(elem);

            if (isAutoScrolling) {
                scrollContainer.scrollTop = scrollContainer.scrollHeight;
            }

            if (Console_array.length > Console_max_size) Console_array.pop();

        };

        connection.onclose = function () {
            console.log('WebSocket connection closed');
        };
    </script>

    <script>
        document.getElementById("status-1").addEventListener("mousedown", function (ev) {
            resize_vertical_bars(ev, 0);
        });
        document.getElementById("status-1").addEventListener("touchstart", function (ev) {
            resize_vertical_bars(ev, 0);
        });

        document.getElementById("status-2").addEventListener("mousedown", function (ev) {
            resize_vertical_bars(ev, 1);
        });
        document.getElementById("status-2").addEventListener("touchstart", function (ev) {
            resize_vertical_bars(ev, 1);
        });

        document.getElementById("Settings Column Resizer").addEventListener("mousedown", function (ev) {
            resize_dir_set(ev);
        });
        document.getElementById("Settings Column Resizer").addEventListener("touchstart", function (ev) {
            resize_dir_set(ev);
        });


        window.addEventListener("DOMContentLoaded", function () {
            sb = document.getElementById("Status Bar");
            width = sb.clientWidth;
            inc = width / sb.children.length;
            for (index = 0; index < sb.children.length; index++) {
                const element = sb.children[index];
                element.setAttribute("style", `width: ${inc}px;`);
                if (index != 0) {
                    bars.push(inc * index);
                }
            }
            refresh_dir_set();
            files();
        })
    </script>

</body>

</html>